---
title: "Prosocial_effort_analysis"
author: "Patricia Lockwood & Jo Cutler"
date: "14/05/2021"
output: 
  html_document:
    keep_md: true
editor_options: 
  markdown: 
    wrap: 72
---

## Set up and functions

```{r setup, include=FALSE}

## Set up and functions

knitr::opts_chunk$set(echo = TRUE)
options(digits = 2)

# load required packages and functions

require(pacman)
pacman::p_load(afex, # mixed models
               boot, # bootstrapping
               coin, # used by other packages
               cowplot, # arrange plots
               # DescTools, # kendall's tau
               ggbrace, # for drawing brackets on plot
               ggpubr, # extra plot functions
               ggtext, # formatting text
               grid, # plot dimensions
               lme4, # mixed models
               optimx, # faster mixed fits
               parallel, # use multiple cores
               magick, # image manipulation
               parameters, # format and standardise
               pals, # additional colour palettes
               pracma, # for squareform function
               psych, # for statistical tests
               R.matlab, # read in matlab formats
               kableExtra, # table formatting
               rstatix, # for Wilcoxon effect sizes
               tidyverse, # ggplot, dplyr packages
               tidyselect)

# function to format p values taken from https://stackoverflow.com/questions/23018256/printing-p-values-with-0-001

pvalr <- function(pvals, sig.limit = .001, digits = 3, html = FALSE) {
  
  roundr <- function(x, digits = 1) {
    res <- sprintf(paste0('%.', digits, 'f'), x)
    zzz <- paste0('0.', paste(rep('0', digits), collapse = ''))
    res[res == paste0('-', zzz)] <- zzz
    res
  }
  
  sapply(pvals, function(x, sig.limit) {
    if (x < sig.limit){
      if (html) {return(sprintf('&lt; %s', format(sig.limit)))
      } else {return(sprintf('<%s', format(sig.limit)))}
    }
    if (x > .1){
      if (html) {return(sprintf('&equals;%s', format(roundr(x, digits = 2)))) 
      } else {return(sprintf('=%s', format(roundr(x, digits = 2))))}
    } else {
      if (html) {return(sprintf('&equals;%s', format(roundr(x, digits = digits))))
      } else {return(sprintf('=%s', format(roundr(x, digits = digits))))}
    }
  }, sig.limit = sig.limit)
}

# custom function to calculate Kendall's tau-a correlations based on MATLAB RSA toolbox version
# provides same results as DescTools::KendallTauA (https://www.rdocumentation.org/packages/DescTools/versions/0.99.42/topics/KendallTauA)
# but faster (see https://www.rdocumentation.org/packages/DescTools/versions/0.99.42/topics/ConDisPairs)

KTA <- function(a, b = NULL){
  
  K <- 0
  n <- length(a)
  
  for (k in 1:n-1){
    pairRelations.a <- sign(a[k]-a[k+1:n])
    pairRelations.b <- sign(b[k]-b[k+1:n])
    K <- K + sum(pairRelations.a*pairRelations.b, na.rm = T)
  }
  
  taua <- K / (n*(n-1)/2)
  
  return(taua)
  
}

```

```{r, warning=FALSE, message=FALSE, echo=FALSE}

## general settings

# 1 to save, 0 to not save
saveplots <- 0
savecsvs <- 0

# settings used throughout script to make figures the same height and text size
resolution <- 300
plotH <- 4
plotW <- 2.5
corrplotW <- plotH*2
modplotW <- plotH*1.55
axtext <- 16
axtitle <- 18

# colours
otherselfcols <- c('#4472C4', '#FF0000')
otherselfdots <- c('light blue', '#FF9595')
othercorcols <- c('#4472C4')
rdmcols <- parula(25)#c('#4120AF', '#277AFF', '#31C2B9', '#CCC000', '#F8FB00')

# figure labels with symbols
taulabel <- 'Kendall’s \u03C4<sub>A</sub>'
klabel <- '*\u039A* parameter'
paramestlab <- "Parameter estimates (a.u)"

```

```{r, warning=FALSE, message=FALSE, echo=FALSE}

## load data

# trial by trial data for choices and force

d.tbt <- read.csv('data/lme_data_PM_ID.csv')                  

d.tbt <- d.tbt %>%
  mutate(Trial = rep(1:200,length(unique(d.tbt$ID))))                 %>% # add index of trial number
  mutate(Trial = scale(Trial))                                        %>% # mean centre
  filter(chosen !=2)                                                  %>% # get rid of non-responded trials
  mutate(ID = factor(ID))                                             %>% # recode as factor
  mutate(Recipient = factor(Recipient, 
                            levels = c('1', '2'), 
                            labels = c('Self', 'Other')))             %>% # recode as factor
  mutate(Effort.f = factor(Effort))                                   %>% # recode as factor
  mutate(Reward.f = factor(Reward))                                   %>% # recode as factor
  mutate(Effort.r = Effort)                                           %>% # keep raw value
  mutate(Reward.r = Reward)                                           %>% # keep raw value
  mutate(Success.f = factor(Success))                                     # recode as factor

d.tbt$timeinwindow[d.tbt$timeinwindow > 3] <- NA

# subset for force analysis
d.tbt.f <- d.tbt %>% 
  mutate(Effort = scale(Effort))                                      %>% # mean centre
  mutate(Reward = scale(Reward))                                      %>% # mean centre
  filter(chosen == 1)                                                     # get rid of rest & non-responded trials

d.tbt <- d.tbt %>%
  mutate(Effort = Effort^2)                                           %>% # square
  mutate(Effort = scale(Effort))                                      %>% # mean centre
  mutate(Reward = scale(Reward))                                          # mean centre

# data with modelling parameters & fMRI results (except ROI RSA below)

d.wide <- read.csv('data/PM_fmri_questionnaire_wo_excluded_totals_share.csv') %>% # get data 
  # make names consistent for pivot_longer
  rename('difference_k' = other_k_self_k, 
         'other_k' = other_K, 
         'self_ACCg_pattern' = ACCg_pattern_self, 
         'other_ACCg_pattern' = ACCg_pattern_other,
         'self_TPJ_force' = TPJ_Self_force,
         'other_TPJ_force' = TPJ_Other_force,
         'other_ACCg_force' = other_Accg_force,
         'self_midbrain_SV_RSA' = self_midbrain_WB_RSA,
         'other_midbrain_SV_RSA' = other_midbrain_WB_RSA)

d <- d.wide %>% 
  pivot_longer(cols = starts_with(c('self','other')), 
               names_to = c('Recipient', '.value'),
               names_pattern = '(self|other)_(.*)') %>% # transform to long-format (for ggplot)
  mutate(Recipient = factor(Recipient, 
                            levels = c('other', 'self'), 
                            labels = c('Other', 'Self'))) %>% # recode agent as factor
  mutate(ID = factor(scanningID))  # recode subject ID as factor

# data with model comparison results

d.rel.bic <- read.csv('data/model_comp_7_10_relative_BIC.csv')

# load MATLAB SPM output containing data for RSA

brainRDM <- readMat('data/makeBrainRDMs_corr_16_6_22_all.mat')[["brainRDM"]]
Models <- readMat('data/modelRDMs_May2020.mat')[["Models"]]

# load RDMs for heatmaps

rdmnames <- c("e2r2", "e2r3", "e2r4", "e2r5", "e2r6", 
              "e3r2", "e3r3", "e3r4", "e3r5", "e3r6", 
              "e4r2", "e4r3", "e4r4", "e4r5", "e4r6", 
              "e5r2", "e5r3", "e5r4", "e5r5", "e5r6", 
              "e6r2", "e6r3", "e6r4", "e6r5", "e6r6")

d.rdm.rew <- read.csv('data/rew_RDM.csv', col.names = rdmnames, header = F) %>% 
  mutate(ycondition = rdmnames) %>% 
  pivot_longer(cols = contains("e"), names_to = "xcondition") %>% 
  mutate(xcondition = factor(xcondition)) %>% 
  mutate(ycondition = factor(ycondition))


d.rdm.eff <- read.csv('data/eff_RDM.csv', col.names = rdmnames, header = F) %>% 
  mutate(ycondition = rdmnames) %>% 
  pivot_longer(cols = contains("e"), names_to = "xcondition") %>% 
  mutate(xcondition = factor(xcondition)) %>% 
  mutate(ycondition = factor(ycondition))

d.rdm.sV.s <- read.csv('data/sV_RDM_mean_self.csv', col.names = rdmnames, header = F) %>% 
  mutate(ycondition = rdmnames) %>% 
  pivot_longer(cols = contains("e"), names_to = "xcondition") %>% 
  mutate(xcondition = factor(xcondition)) %>% 
  mutate(ycondition = factor(ycondition))

d.rdm.sV.o <- read.csv('data/sV_RDM_mean_other.csv', col.names = rdmnames, header = F) %>% 
  mutate(ycondition = rdmnames) %>% 
  pivot_longer(cols = contains("e"), names_to = "xcondition") %>% 
  mutate(xcondition = factor(xcondition)) %>% 
  mutate(ycondition = factor(ycondition))

d.means <- d.tbt %>%
  dplyr::group_by(ID, Recipient) %>%
  dplyr::summarise(Accept = mean(chosen), RT = mean(RT, na.rm = T), .groups = "drop")

self.other.mean.se <- d.means %>%
  dplyr::group_by(Recipient) %>%
  dplyr::summarise(mean.Accept = mean(Accept), se.Accept = std_err(Accept), mean.RT = mean(RT), se.RT = std_err(RT), .groups = "drop")

d.success <- d.tbt.f %>%
  dplyr::group_by(ID, Recipient) %>%
  dplyr::summarise(TiW = mean(timeinwindow, na.rm = T), Success = mean(Success), Force = mean(Force_norm), .groups = "drop")

self.other.success <- d.success %>%
  dplyr::group_by(Recipient) %>%
  dplyr::summarise(mean.TiW = mean(TiW), se.TiW = std_err(TiW), mean.Success = mean(Success), se.Success = std_err(Success), mean.Force = mean(Force), se.Force = std_err(Force), .groups = "drop")

self.other.mean.se <- left_join(self.other.mean.se, self.other.success, by = "Recipient")

d.means <- left_join(d.means, d.success)

d.means.wide <- pivot_wider(d.means, id_cols = "ID", names_from = "Recipient", values_from = c("Accept", "RT", "Success", "TiW", "Force"))

if (savecsvs == 1) {write_csv(d.means.wide, "data/participant_averages_PM_fmri.csv")} # save csv for JASP BF analysis

```

## Analyse choice data

```{r, warning=FALSE, message=FALSE, echo=FALSE}

# model with recipient, effort squared, and reward - 3 way interaction

# parametric bootstrapping for p values takes a very long time so load saved version

# to run uncomment optimx and parallel in loading functions section
# (nc <- detectCores()) # number of cores
# cl <- makeCluster(rep("localhost", nc)) # make cluster
# clusterEvalQ(cl, library(optimx)) # need to load optimx in cluster
# 
# set.seed(7531) # make it reproducible
# 
# m.choice.rs <- mixed(chosen ~ Recipient*Effort*Reward + (1 + Recipient + Effort + Reward + Recipient:Effort + Recipient:Reward + Effort:Reward || ID),
#                   data = d.tbt, family = 'binomial',
#                   check_contrasts = T,  expand_re = T,
#                   method = "PB", type = 2, cl = cl, args_test = list(cl = cl),
#                   control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# 
# save(m.choice.rs, file = "output/choice_model_rs.RData")
# 
# stopCluster(cl)

load("output/choice_model_rs.RData")

# faster version without bootstrapping

m.choice.fast.rs <- mixed(chosen ~ Recipient*Effort*Reward + 
                            (1 + Recipient + Effort + Reward + Recipient:Effort + Recipient:Reward + Effort:Reward || ID),
                          data = d.tbt, family = 'binomial', method = "LRT",
                          check_contrasts = T, type = 2, return = "merMod", expand_re = T,
                          control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

r.choice.rs.a <- anova(m.choice.rs) # get chisq stats, dfs and bootstrapped p values

# format and combine results

r.choice.rs <- 
  model_parameters(m.choice.rs$full_model[[3]], standardize = "refit", exponentiate = T) %>% # exponentiate for odds ratios
  # model_parameters(m.choice.rs, standardize = "refit", exponentiate = T) %>% # if looking at results from fast version
  filter(Effects == "fixed") %>% 
  select(!c(df_error, Effects)) %>% #, Group
  mutate(Parameter = str_replace(Parameter, pattern = "Recipient1", replacement = "Recipient (Self vs. Other)")) %>% 
  mutate(Parameter = str_replace_all(Parameter, pattern = ":", replacement = " * ")) %>% 
  add_column("Chisq" = c(NA, r.choice.rs.a$Chisq), .before = "p") %>%
  add_column("df" = c(NA, r.choice.rs.a$`Chi Df`), .before = "p") %>%
  mutate(p = c(NA, r.choice.rs.a$`Pr(>PB)`)) # comment out if looking at results from fast version

# check effects of trial number

m.choice.trial <- mixed(chosen ~ Trial*Recipient + Recipient*Effort*Reward + 
                          (1 + Trial + Recipient + Effort + Reward + 
                             Recipient:Trial + Recipient:Effort + Recipient:Reward + Effort:Reward || ID),
                        data = d.tbt, family = 'binomial', method = "LRT",
                        check_contrasts = T, type = 2, return = "merMod", expand_re = T,
                        control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

r.choice.trial.as <- anova(m.choice.trial) # get chisq stats, dfs and bootstrapped p values

r.choice.trial <- 
  model_parameters(m.choice.trial, standardize = "refit", exponentiate = T) %>% # if looking at results from fast version
  filter(Effects == "fixed") %>% 
  select(!c(df_error, Effects)) %>% #, Group
  mutate(Parameter = str_replace(Parameter, pattern = "Recipient1", replacement = "Recipient (Self vs. Other)")) %>% 
  mutate(Parameter = str_replace_all(Parameter, pattern = ":", replacement = " * ")) %>% 
  add_column("Chisq" = c(NA, r.choice.trial.as$Chisq), .before = "p") %>%
  add_column("df" = c(NA, r.choice.trial.as$`Chi Df`), .before = "p")

# Wilcoxon signed-rank test on choice for self vs other

wilcox.choice <- wilcox.test(d.means$Accept[d.means$Recipient=='Other'], 
                              d.means$Accept[d.means$Recipient=='Self'], 
                              paired = T, conf.int = T)
Zstat.choice <- qnorm(wilcox.choice$p.value/2)
wilcox.es.choice <- wilcox_effsize(Accept ~ Recipient, data = d.means, ci = TRUE) %>% 
  as.data.frame() %>% 
  add_column("measure" = "Accept") %>% 
  add_column("Z" = Zstat.choice) %>% 
  add_column("p" = wilcox.choice[["p.value"]])

```

## Analyse `r "<i>\u039A</i>"` parameters

```{r, warning=FALSE, message=FALSE, echo=FALSE}

# Wilcoxon signed-rank test on k parameters for self vs other 

wilcox.k <- wilcox.test(d$k[d$Recipient=='Other'], d$k[d$Recipient=='Self'], paired = T, conf.int = T)
Zstat.k <- qnorm(wilcox.k$p.value/2) # get z value
wilcox.es.k <- wilcox_effsize(k ~ Recipient, data = d, ci = TRUE) # get confidence intervals

```

## Analyse force data

```{r, warning=FALSE, message=FALSE, echo=FALSE}

# model with recipient, effort, and reward - 3 way interaction

# parametric bootstrapping for p values (much faster than for choice) or load saved version

# # to run uncomment optimx and parallel in loading functions section
# (nc <- detectCores()) # number of cores
# cl <- makeCluster(rep("localhost", nc)) # make cluster
# clusterEvalQ(cl, library(optimx)) # need to load optimx in cluster
# 
# set.seed(8642) # make it reproducible
# 
# m.force.rs <- mixed(Force_norm ~ Recipient*Effort.f*Reward.f + (1 + Recipient + Effort.f || ID), data = d.tbt.f,
#                  check_contrasts = T, expand_re = T,
#                  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)),
#                  method = "PB", type = 2, cl = cl, args_test = list(cl = cl))
# 
# save(m.force.rs, file = "output/force_model_rs.RData")
# 
# stopCluster(cl)

load("output/force_model_rs.RData")

r.force.rs <- anova(m.force.rs) # get chisq stats, dfs and bootstrapped p values

# format and combine results
r.force.rs <- r.force.rs %>% 
  add_column("Parameter" = rownames(r.force.rs), .before = 1) %>% 
  as_tibble() %>%
  mutate(Parameter = str_replace(Parameter, pattern = "Recipient", replacement = "Recipient (Self vs. Other)")) %>%
  mutate(Parameter = str_replace(Parameter, pattern = "Reward.f", replacement = "Reward")) %>%
  mutate(Parameter = str_replace(Parameter, pattern = "Effort.f", replacement = "Effort")) %>%
  mutate(Parameter = str_replace_all(Parameter, pattern = ":", replacement = " * ")) %>% 
  select(!"Pr(>Chisq)") %>%
  rename("df" = "Chi Df") %>%
  rename("p" = "Pr(>PB)")

# Wilcoxon signed-rank test on force for self vs other

wilcox.force <- wilcox.test(d.means$Force[d.means$Recipient=='Other'], 
                            d.means$Force[d.means$Recipient=='Self'], 
                            paired = T, conf.int = T)
Zstat.force <- qnorm(wilcox.force$p.value/2)
wilcox.es.force <- wilcox_effsize(Force ~ Recipient, data = d.means, ci = TRUE) %>% 
  as.data.frame() %>% 
  add_column("measure" = "Force") %>% 
  add_column("Z" = Zstat.force) %>% 
  add_column("p" = wilcox.force[["p.value"]])

# Wilcoxon signed-rank test on success rate for self vs other

wilcox.success <- wilcox.test(d.means$Success[d.means$Recipient=='Other'], 
                              d.means$Success[d.means$Recipient=='Self'], 
                              paired = T, conf.int = T)
Zstat.success <- qnorm(wilcox.success$p.value/2)
wilcox.es.success <- wilcox_effsize(Success ~ Recipient, data = d.means, ci = TRUE) %>% 
  as.data.frame() %>% 
  add_column("measure" = "Success") %>% 
  add_column("Z" = Zstat.success) %>% 
  add_column("p" = wilcox.success[["p.value"]])

m.success.trial <- mixed(Success ~ Trial*Recipient + Recipient*Effort*Reward + 
                           (1 + Recipient + Effort || ID),
                         data = d.tbt.f, family = 'binomial', method = "LRT",
                         check_contrasts = T, type = 2, return = "merMod", expand_re = T,
                         control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

r.success.trial.as <- anova(m.success.trial) # get chisq stats, dfs and bootstrapped p values

r.success.trial <- 
  model_parameters(m.success.trial, standardize = "refit", exponentiate = T) %>% # if looking at results from fast version
  filter(Effects == "fixed") %>% 
  select(!c(df_error, Effects)) %>% #, Group
  mutate(Parameter = str_replace(Parameter, pattern = "Recipient1", replacement = "Recipient (Self vs. Other)")) %>% 
  mutate(Parameter = str_replace_all(Parameter, pattern = ":", replacement = " * ")) %>% 
  add_column("Chisq" = c(NA, r.success.trial.as$Chisq), .before = "p") %>%
  add_column("df" = c(NA, r.success.trial.as$`Chi Df`), .before = "p")

```

## Analyse RT & time in window data

```{r, warning=FALSE, message=FALSE, echo=FALSE}

wilcox.rt <- wilcox.test(d.means$RT[d.means$Recipient=='Other'], 
                         d.means$RT[d.means$Recipient=='Self'], 
                         paired = T, conf.int = T)
Zstat.rt <- qnorm(wilcox.rt$p.value/2)
wilcox.es.rt <- wilcox_effsize(RT ~ Recipient, data = d.means, ci = TRUE) %>% 
  as.data.frame() %>% 
  add_column("measure" = "RT") %>% 
  add_column("Z" = Zstat.rt) %>% 
  add_column("p" = wilcox.rt[["p.value"]])

wilcox.tiw <- wilcox.test(d.means$TiW[d.means$Recipient=='Other'], 
                          d.means$TiW[d.means$Recipient=='Self'], 
                          paired = T, conf.int = T)
Zstat.tiw <- qnorm(wilcox.tiw$p.value/2)
wilcox.es.tiw <- wilcox_effsize(TiW ~ Recipient, data = d.means, ci = TRUE) %>% 
  as.data.frame() %>% 
  add_column("measure" = "TiW") %>% 
  add_column("Z" = Zstat.tiw) %>% 
  add_column("p" = wilcox.tiw[["p.value"]])

d.means.wide$RT_Diff_os <- d.means.wide$RT_Other - d.means.wide$RT_Self
d.means.wide$TiW_Diff_so <- d.means.wide$TiW_Self - d.means.wide$TiW_Other

rt.tiw.corr <- cor.test(d.means.wide$RT_Diff_os, d.means.wide$TiW_Diff_so, method = "spearman")

self.other.mean.se.diff <- self.other.mean.se %>% 
  select(!Recipient) %>% 
  head() %>%
  rownames_to_column() %>%
  pivot_longer(cols = -rowname) %>%
  pivot_wider(names_from = rowname) %>%
  rename("category" = 1) %>%
  as.data.frame() %>% 
  rename("self" = "1") %>% 
  rename("other" = "2") %>%
  separate(col = category, into = c('type', 'measure')) %>% 
  pivot_wider(values_from = c("self", "other"), names_from = type, id_cols = measure)

self.other.diff <- bind_rows(wilcox.es.choice %>% 
                               select("measure", "Z", "effsize", "conf.low", "conf.high", "p"),
                             wilcox.es.rt %>% 
                               select("measure", "Z", "effsize", "conf.low", "conf.high", "p"),
                             wilcox.es.tiw %>% 
                               select("measure", "Z", "effsize", "conf.low", "conf.high", "p"),
                             wilcox.es.success %>% 
                               select("measure", "Z", "effsize", "conf.low", "conf.high", "p"),
                             wilcox.es.force %>% 
                               select("measure", "Z", "effsize", "conf.low", "conf.high", "p"))


self.other.mean.se.diff <- left_join(self.other.mean.se.diff, self.other.diff, by = "measure")
  
```

```{r, warning=FALSE, message=FALSE, echo=FALSE, fig.height=plotH, fig.width=corrplotW}

## plot choices

# if (saveplots == 1) {tiff("plotpanels/agent_by_effort_choice.tiff", units="in", width = corrplotW, height = plotH, res = resolution)}

d.effort <- d.tbt %>% 
  group_by(ID, Recipient, Effort.f) %>% 
  summarise(chosen = mean(chosen)) %>% 
  mutate(Recipient = factor(Recipient, 
                            levels = c('Other', 'Self'))) # create data-frame of subject means

plot.effort.choice <- ggplot(d.effort, aes(x = Effort.f, y = chosen, group = Recipient, color = Recipient, fill = Recipient)) + 
  stat_summary(fun = mean, size = 0.5, geom = 'bar', alpha = 0.8, colour = 'black',
               position=position_dodge(0.5), width = 0.5) +
  geom_jitter(position = position_jitterdodge(dodge.width = 0.5, jitter.height = 0, jitter.width = 0.1),
              size = 2.5, alpha = 0.8, stroke=0, show.legend = FALSE) +
  stat_summary(fun = mean, size = 0.5, geom = 'bar', alpha = 0, colour = 'black',
               position=position_dodge(0.5), width = 0.5) +
  stat_summary(fun.data = mean_se, geom = 'errorbar', colour = 'black', width = 0, position=position_dodge(0.5)) +
  xlab('Effort level') + 
  ylab("Proportion accepted") + 
  theme_classic() + 
  scale_fill_manual(values = otherselfcols) + 
  scale_color_manual(values = otherselfdots) + 
  theme(legend.title = element_blank(),
        legend.text = element_text(size = axtext, margin = margin(t = 2, b = 2, unit = 'pt')),
        axis.text.y=element_text(size = axtext),
        axis.text.x=element_text(size = axtext),
        axis.title=element_markdown(size = axtitle),
        legend.key.size = unit(20,'pt')) 

# plot.effort.choice

# if (saveplots == 1) {dev.off()}

# plot choices by agent*reward

# if (saveplots == 1) {tiff("plotpanels/agent_by_reward_choice.tiff", units="in", width = corrplotW, height = plotH, res = resolution)}

d.reward <- d.tbt %>% 
  group_by(ID, Recipient, Reward.f) %>% 
  summarise(chosen = mean(chosen)) %>% 
  mutate(Recipient = factor(Recipient, 
                            levels = c('Other', 'Self'))) # create data-frame of subject means

plot.reward.choice <- ggplot(d.reward, aes(x = Reward.f, y = chosen, group = Recipient, color = Recipient, fill = Recipient)) + 
  stat_summary(fun = mean, size = 0.5, geom = 'bar', alpha = 0.8, colour = 'black',
               position=position_dodge(0.5), width = 0.5) +
  geom_jitter(position = position_jitterdodge(dodge.width = 0.5, jitter.height = 0, jitter.width = 0.1),
              size = 2.5, alpha = 0.8, stroke=0, show.legend = FALSE) +
  stat_summary(fun = mean, size = 0.5, geom = 'bar', alpha = 0, colour = 'black',
               position=position_dodge(0.5), width = 0.5) +
  stat_summary(fun.data = mean_se, geom = 'errorbar', colour = 'black', width = 0, position=position_dodge(0.5)) +
  xlab('Reward level') + 
  ylab("Proportion accepted") + 
  theme_classic() + 
  scale_fill_manual(values = otherselfcols) + 
  scale_color_manual(values = otherselfdots) + 
  theme(legend.title = element_blank(),
        legend.text = element_text(size = axtext, margin = margin(t = 2, b = 2, unit = 'pt')),
        axis.text.y=element_text(size = axtext),
        axis.text.x=element_text(size = axtext),
        axis.title=element_markdown(size = axtitle),
        legend.key.size = unit(20,'pt')) 

# plot.reward.choice

# if (saveplots == 1) {dev.off()}

```

```{r, warning=FALSE, message=FALSE, echo=FALSE}

# plot model comparison results

plot.prop.bic <- ggplot(d.rel.bic, aes(x="", y=proportion, fill=as.factor(model))) +
  geom_bar(stat="identity", width=2, colour = "white") +
  coord_polar("y", start = 1.01229097) +
  geom_text(aes(label = paste0(proportion, "%")), position = position_stack(vjust=0.5), 
            colour = "white", size = (axtext/3)) +
  labs(x = NULL, y = NULL, fill = NULL) +
  theme_classic() +
  theme(axis.line = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        legend.position = 'none') +
  scale_fill_manual(values=c("#203964", "#7031A0"))

plot.rel.bic <- ggplot(d.rel.bic, aes(x = as.factor(model), y = rel.bic)) + 
  geom_bar(stat = "identity", size = 0.5, alpha = 0.8, colour = 'black',
           fill = '#EDEDED', position=position_dodge(0.5), width = 0.5) +
  scale_y_continuous(name = "BIC relative to\nwinning model") +
  scale_x_discrete(name = 'Model number') + 
  theme_classic() + 
  theme(legend.position = 'none',
        axis.text=element_text(size = axtext),
        axis.text.x=element_text(size = axtext),
        axis.title.x = element_text(size = axtitle),
        axis.title.y = element_text(size = axtitle))

# create text for winning model formula
win.mod.text <- data.frame(
  label = c("**<span style='font-size:18pt'>Winning model</span>**<br><br>
  <span style='font-size:16pt'>SV = R – *\u039AE*<sup>2</sup></span><br><br>
  <span style='font-size:16pt'>Subjective value = Reward – (Discount x Effort<sup>2</sup>)</span>",
  "<span style='font-size:16pt'>*\u039A*<sub>self</sub> if self trial</span><br><br>
  <span style='font-size:16pt'>*\u039A*<sub>other</sub> if other trial</span>"),
  x = c(0.5, 0.35), y = c(1, 0.4),
  hjust = c(0.5, 0), vjust = c(0.5, 0.5),
  orientation = c("upright", "upright"),
  text.color = c("black", "black"), box.color = c(NA, NA),
  fill = c(NA, NA), halign = c("center", "center")
)

# create ggplot text box with winning model formula
win.mod <- ggplot(win.mod.text) +
  geom_textbox(mapping = aes(0.5, 0.75, 
                             label = "<br><br><br><br><br><br><br><br><br><br><br><br><br><br>", text.color = "white", 
                             box.color = "black", fill = "white", hjust = 0.5, vjust = 0.5), width = unit(0.9, "npc")) +
  geom_textbox(mapping = aes(x, y, 
                             label = label, text.color = text.color, 
                             box.color = box.color, fill = fill, hjust = hjust, vjust = vjust, orientation = orientation, halign = hjust), width = unit(0.8, "npc")) +
  scale_discrete_identity(aesthetics = c("color", "fill", "orientation")) +
  xlim(0, 1) + ylim(0, 1.5) + 
  geom_brace(aes(c(0.3,0.35), c(0.34, 0.51), label = "\u039A="), inherit.data=F, labelsize=8, rotate = 270, fontface = "italic") +
  theme_classic() +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.title.x = element_blank(),
        axis.line.x = element_blank(),
        axis.title.y = element_blank(),
        axis.line.y = element_blank())

```

```{r, warning=FALSE, message=FALSE, echo=FALSE}

# data with model comparison results

d.rel.bic <- read.csv('data/model_comp_relative_BIC.csv')

d.rel.bic$model_wrong <- d.rel.bic$model
d.rel.bic$row <- NA
d.rel.bic$type <- NA

new <- c(1:12, 29:40, 13:24, 25:28)

for (n in 1:40) {
  w <- new[n]
  d.rel.bic$model[d.rel.bic$model_wrong == w] <- n
  if (n <= 12){
    d.rel.bic$row[d.rel.bic$model_wrong == w] <- 1
    d.rel.bic$type[d.rel.bic$model_wrong == w] <- 1
  } else if (n >= 13 & n <=24){
    d.rel.bic$row[d.rel.bic$model_wrong == w] <- 1
    d.rel.bic$type[d.rel.bic$model_wrong == w] <- 2
  } else if (n >= 25 & n <=36){
    d.rel.bic$row[d.rel.bic$model_wrong == w] <- 2
    d.rel.bic$type[d.rel.bic$model_wrong == w] <- 3
  } else if (n >= 37){
    d.rel.bic$row[d.rel.bic$model_wrong == w] <- 2
    d.rel.bic$type[d.rel.bic$model_wrong == w] <- 4
  }
}

d.rel.bic <- d.rel.bic %>% 
  mutate(type = factor(type, 
                       labels = c('m1-m12: effort discounting',
                                  'm13-m24: effort & reward',
                                  'm25-m36: reward sensitivity',
                                  'm37-m40: reward-effort difference')))

d.rel.bic <-
  d.rel.bic %>% 
  add_row(model = 41, rel.bic = NA, row = 2) %>% 
  add_row(model = 42, rel.bic = NA, row = 2) %>% 
  add_row(model = 43, rel.bic = NA, row = 2) %>% 
  add_row(model = 44, rel.bic = NA, row = 2) %>% 
  add_row(model = 45, rel.bic = NA, row = 2) %>% 
  add_row(model = 46, rel.bic = NA, row = 2) %>% 
  add_row(model = 47, rel.bic = NA, row = 2) %>% 
  add_row(model = 48, rel.bic = NA, row = 2)

# plot model comparison results for all models
plot.prop.bic10 <- ggplot(d.rel.bic, aes(x="", y=proportion10, fill=as.factor(model))) +
  geom_bar(stat="identity", width=2, colour = "white") +
  coord_polar("y", start = 1.01229097) +
  geom_text(aes(label = paste0("m", model, "\n", proportion10, "%")), position = position_stack(vjust=0.5), 
            colour = "white", size = (axtext/3)) +
  labs(x = NULL, y = NULL, fill = NULL) +
  theme_classic() +
  theme(axis.line = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        legend.position = 'none',
        panel.background = element_rect(fill = "transparent"),
        plot.background = element_rect(fill = "transparent", color = NA)) +
  scale_fill_manual(values=c("#203964", "#7031A0"))

plot.prop.bic19 <- ggplot(d.rel.bic, aes(x="", y=proportion19, fill=as.factor(model))) +
  geom_bar(stat="identity", width=2, colour = "white") +
  coord_polar("y", start = 0.698132) +
  geom_text(aes(label = paste0("m", model, "\n", proportion19, "%")), position = position_stack(vjust=0.5), 
            colour = "white", size = (axtext/3)) +
  labs(x = NULL, y = NULL, fill = NULL) +
  theme_classic() +
  theme(axis.line = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        legend.position = 'none',
        panel.background = element_rect(fill = "transparent"), 
        plot.background = element_rect(fill = "transparent", color = NA)) +
  scale_fill_manual(values=c("#203964", "#a0319a"))

plot.prop.bic22 <- ggplot(d.rel.bic, aes(x="", y=proportion22, fill=as.factor(model))) +
  geom_bar(stat="identity", width=2, colour = "white") +
  coord_polar("y", start = 1.50098) +
  geom_text(aes(label = paste0("m", model, "\n", proportion22, "%")), position = position_stack(vjust=0.5), 
            colour = "white", size = (axtext/3)) +
  labs(x = NULL, y = NULL, fill = NULL) +
  theme_classic() +
  theme(axis.line = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        legend.position = 'none',
        panel.background = element_rect(fill = "transparent"), 
        plot.background = element_rect(fill = "transparent", color = NA)) +
  scale_fill_manual(values=c("#203964", "#a03161"))

plot.rel.bic.rs <- ggplot(d.rel.bic %>% subset(!is.na(type)), aes(x = model, y = rel.bic, alpha = type)) + 
  geom_bar(stat = "identity", size = 0.5, colour = 'black',
           fill = 'black', position=position_dodge(0.5), width = 0.5) +
  scale_y_continuous(name = "BIC relative to\nwinning model") +
  scale_x_continuous(name = 'Model number (m)', breaks = c(1:24), limits = c(0.4,24.6)) + 
  scale_alpha_manual(values = c(0.75, 0.5, 0.25, 0)) +
  theme_classic() + 
  theme(legend.title = element_blank(),
        legend.text = element_text(size = axtext),
        axis.text=element_text(size = axtext),
        axis.text.x=element_text(size = axtext),
        axis.title.x = element_text(size = axtitle),
        axis.title.y = element_text(size = axtitle))

leg.rel.bic.rs <- get_legend(plot.rel.bic.rs)

plot.rel.bic.rs <- ggplot(d.rel.bic %>% subset(row == 1), aes(x = as.factor(model), y = rel.bic, alpha = type)) + 
  geom_bar(stat = "identity", size = 0.5, colour = 'black',
           fill = 'black', position=position_dodge(0.5), width = 0.5) +
  scale_y_continuous(name = "BIC relative to\nwinning model", limits = c(-50, 5000), breaks = seq(from = 0, to = 5000, by = 1000)) +
  scale_x_discrete(name = 'Model number (m)') + 
  scale_alpha_manual(values = c(0.75, 0.5, 0.25, 0)) +
  theme_classic() + 
  theme(legend.position = 'none',
        legend.text = element_text(size = axtext),
        axis.text=element_text(size = axtext),
        axis.text.x=element_text(size = axtext),
        axis.title.x = element_text(size = axtitle),
        axis.title.y = element_text(size = axtitle))

plot.rel.bic.rs2 <- ggplot(d.rel.bic %>% subset(row == 2), aes(x = as.factor(model), y = rel.bic, alpha = type)) + 
  geom_bar(stat = "identity", size = 0.5, colour = 'black',
           fill = 'black', position=position_dodge(0.5), width = 0.5) +
  scale_y_continuous(name = "BIC relative to\nwinning model", limits = c(-50, 5000), breaks = seq(from = 0, to = 5000, by = 1000)) +
  scale_x_discrete(name = 'Model number (m)', labels = c(as.character(c(25:40)), rep("",8))) + 
  scale_alpha_manual(values = c(0.25, 0)) +
  theme_classic() + 
  theme(legend.position = 'none',
        axis.text=element_text(size = axtext),
        axis.text.x=element_text(size = axtext),
        axis.title.x = element_text(size = axtitle),
        axis.title.y = element_text(size = axtitle))

```

```{r, warning=FALSE, message=FALSE, echo=FALSE}

# model comparison results with different kbounds

# d.rel.bic <- read.csv('data/model_comp_kbounds.csv')
# 
# plot.rel.bic.1.5 <- ggplot(d.rel.bic, aes(x = as.factor(model), y = rel.bic1.5)) + 
#   geom_bar(stat = "identity", size = 0.5, alpha = 0.8, colour = 'black',
#            fill = '#EDEDED', position=position_dodge(0.5), width = 0.5) +
#   scale_y_continuous(name = "BIC relative to\nwinning model") +
#   scale_x_discrete(name = 'Model number') + 
#   theme_classic() + 
#   ggtitle(paste0("0<","*\u039A*","<1.5")) +
#   theme(legend.position = 'none',
#         plot.title=element_markdown(size = axtitle, hjust = 0.5),
#         axis.text=element_text(size = axtext),
#         axis.text.x=element_text(size = axtext),
#         axis.title.x = element_text(size = axtitle),
#         axis.title.y = element_text(size = axtitle))
# 
# plot.rel.bic.3 <- ggplot(d.rel.bic, aes(x = as.factor(model), y = rel.bic3)) + 
#   geom_bar(stat = "identity", size = 0.5, alpha = 0.8, colour = 'black',
#            fill = '#EDEDED', position=position_dodge(0.5), width = 0.5) +
#   scale_y_continuous(name = "BIC relative to\nwinning model") +
#   scale_x_discrete(name = 'Model number') + 
#   theme_classic() + 
#   ggtitle(paste0("0<","*\u039A*","<3")) +
#   theme(legend.position = 'none',
#         plot.title=element_markdown(size = axtitle, hjust = 0.5),
#         axis.text=element_text(size = axtext),
#         axis.text.x=element_text(size = axtext),
#         axis.title.x = element_text(size = axtitle),
#         axis.title.y = element_text(size = axtitle))
# 
# plot.rel.bic.10 <- ggplot(d.rel.bic, aes(x = as.factor(model), y = rel.bic10)) + 
#   geom_bar(stat = "identity", size = 0.5, alpha = 0.8, colour = 'black',
#            fill = '#EDEDED', position=position_dodge(0.5), width = 0.5) +
#   scale_y_continuous(name = "BIC relative to\nwinning model") +
#   scale_x_discrete(name = 'Model number') + 
#   theme_classic() + 
#   ggtitle(paste0("0<","*\u039A*","<10")) +
#   theme(legend.position = 'none',
#         plot.title=element_markdown(size = axtitle, hjust = 0.5),
#         axis.text=element_text(size = axtext),
#         axis.text.x=element_text(size = axtext),
#         axis.title.x = element_text(size = axtitle),
#         axis.title.y = element_text(size = axtitle))
# 
# plot.rel.bic.kbounds <- plot_grid(plot.rel.bic.1.5, plot.rel.bic.3, plot.rel.bic.10, 
#                      nrow = 3, ncol = 1,
#                      label_size = axtitle, labels = "auto", axis = "l", align = "hv")
# 
# plot.rel.bic.kbounds

d.rel.bic <- read.csv('data/model_comp_kbounds.csv')

d.rel.bic$model_wrong <- d.rel.bic$model
d.rel.bic$row <- NA
d.rel.bic$type <- NA

new <- c(1:12, 29:40, 13:24, 25:28)

for (n in 1:40) {
  w <- new[n]
  d.rel.bic$model[d.rel.bic$model_wrong == w] <- n
  if (n <= 12){
    d.rel.bic$row[d.rel.bic$model_wrong == w] <- 1
    d.rel.bic$type[d.rel.bic$model_wrong == w] <- 1
  } else if (n >= 13 & n <=24){
    d.rel.bic$row[d.rel.bic$model_wrong == w] <- 1
    d.rel.bic$type[d.rel.bic$model_wrong == w] <- 2
  } else if (n >= 25 & n <=36){
    d.rel.bic$row[d.rel.bic$model_wrong == w] <- 2
    d.rel.bic$type[d.rel.bic$model_wrong == w] <- 3
  } else if (n >= 37){
    d.rel.bic$row[d.rel.bic$model_wrong == w] <- 2
    d.rel.bic$type[d.rel.bic$model_wrong == w] <- 4
  }
}

d.rel.bic <- d.rel.bic %>% 
  mutate(type = factor(type, 
                       labels = c('m1-m12: effort discounting',
                                  'm13-m24: effort & reward',
                                  'm25-m36: reward sensitivity',
                                  'm37-m40: reward-effort difference')))


plot.rel.bic.1.5 <- ggplot(d.rel.bic, aes(x = as.factor(model), y = rel.bic1.5, alpha = type)) + 
  geom_bar(stat = "identity", size = 0.5, colour = 'black',
           fill = 'black', position=position_dodge(0.5), width = 0.5) +
  scale_y_continuous(name = "BIC relative to\nwinning model") +
  scale_x_discrete(name = 'Model number') + 
  scale_alpha_manual(values = c(0.75, 0.5, 0.25, 0)) +
  theme_classic() + 
  ggtitle(paste0("0<","*\u039A*","<1.5")) +
  theme(legend.position = 'none',
        plot.title=element_markdown(size = axtitle, hjust = 0.5),
        axis.text=element_text(size = axtext),
        axis.text.x=element_text(size = axtext),
        axis.title.x = element_text(size = axtitle),
        axis.title.y = element_text(size = axtitle))

plot.rel.bic.3 <- ggplot(d.rel.bic, aes(x = as.factor(model), y = rel.bic3, alpha = type)) + 
  geom_bar(stat = "identity", size = 0.5, colour = 'black',
           fill = 'black', position=position_dodge(0.5), width = 0.5) +
  scale_y_continuous(name = "BIC relative to\nwinning model") +
  scale_x_discrete(name = 'Model number') + 
  scale_alpha_manual(values = c(0.75, 0.5, 0.25, 0)) +
  theme_classic() + 
  ggtitle(paste0("0<","*\u039A*","<3")) +
  theme(legend.position = 'none',
        plot.title=element_markdown(size = axtitle, hjust = 0.5),
        axis.text=element_text(size = axtext),
        axis.text.x=element_text(size = axtext),
        axis.title.x = element_text(size = axtitle),
        axis.title.y = element_text(size = axtitle))

plot.rel.bic.10 <- ggplot(d.rel.bic, aes(x = as.factor(model), y = rel.bic10, alpha = type)) + 
  geom_bar(stat = "identity", size = 0.5, colour = 'black',
           fill = 'black', position=position_dodge(0.5), width = 0.5) +
  scale_y_continuous(name = "BIC relative to\nwinning model") +
  scale_x_discrete(name = 'Model number') + 
  scale_alpha_manual(values = c(0.75, 0.5, 0.25, 0)) +
  theme_classic() + 
  ggtitle(paste0("0<","*\u039A*","<10")) +
  theme(legend.position = 'none',
        plot.title=element_markdown(size = axtitle, hjust = 0.5),
        axis.text=element_text(size = axtext),
        axis.text.x=element_text(size = axtext),
        axis.title.x = element_text(size = axtitle),
        axis.title.y = element_text(size = axtitle))

```

```{r, warning=FALSE, message=FALSE, echo=FALSE}

## plot parameter recovery

df.pr <- read_csv("data/Parameter_recovery_mle.csv", col_names = T)
# if (saveplots == 1) {tiff("plotpanels/Parameter_recovery.tiff", units="in", res = resolution, width = modplotW, height = plotH)}

h.plot <- ggplot(data = df.pr, aes(x=Simulated, y=Recovered, fill=MLCorr)) + 
  geom_tile() +
  scale_fill_distiller(palette = "Purples", direction = 1,
                       limit = c(-0.25,1.05), 
                       name="Pearson's <i>r</i>") +
  guides(fill = guide_colorbar(title.position = 'right', title.hjust = 0.5, 
                               frame.colour = NULL, barheight = 16, 
                               ticks.colour = 'black', ticks.linewidth = 0.5,  
                               draw.ulim = FALSE, draw.llim = FALSE, override.aes = list(limits = c(0,1)))) +
  scale_x_continuous(breaks = c(1,2,3),
                     labels = c(paste0("<i>\u039A</i>","<sub>self</sub>"), # rename models with k and beta symbols
                                paste0("<i>\u039A</i>","<sub>other</sub>"),
                                paste0("<i>\u03B2</i>"))) +
  scale_y_continuous(breaks = c(1,2,3),
                     labels = c(paste0("<i>\u039A</i>","<sub>self</sub>"),
                                paste0("<i>\u039A</i>","<sub>other</sub>"),
                                paste0("<i>\u03B2</i>"))) +
  theme_classic() + 
  theme(axis.text.x = element_markdown(size = axtext),
        axis.text.y = element_markdown(size = axtext), 
        axis.title = element_text(size = axtitle), 
        legend.title = element_markdown(size = axtitle, angle = 90), 
        legend.text = element_markdown(size = axtext))

# h.plot

# if (saveplots == 1) {dev.off()}

## plot model identifiability

df.mi <- read_csv("data/Model_identifiability_mle_12_models.csv", col_names = T)

if (saveplots == 1) {tiff("plotpanels/Model_iden_bicp.tiff", units="in", res = resolution, width = modplotW, height = plotH)}

bicp.plot <- ggplot(data = df.mi, aes(x=Simulated, y=Estimated, fill=bicp)) + 
  geom_tile() +
  scale_fill_distiller(palette = "Purples", direction = 1,
                       limit = c(0,100), 
                       space = "Lab",       
                       name="Percentage of simulated \nparticipants with lowest BIC") +
  guides(fill = guide_colorbar(title.position = 'right', title.hjust = 0.5, 
                               frame.colour = NULL, barheight = 16, 
                               ticks.colour = 'black', ticks.linewidth = 0.5,  
                               draw.ulim = FALSE, draw.llim = FALSE)) +
  scale_x_continuous(breaks = c(1:12)) +
  scale_y_continuous(breaks = c(1:12)) +
  theme_classic() + 
  theme(axis.text.x = element_markdown(size = axtext),
        axis.text.y = element_markdown(size = axtext), 
        axis.title = element_text(size = axtitle), 
        legend.title = element_text(size = axtitle, angle = 90), 
        legend.text = element_text(size = axtext))

# bicp.plot

# if (saveplots == 1) {dev.off()}

# if (saveplots == 1) {tiff("plotpanels/Model_iden_best.tiff", units="in", res = resolution, width = modplotW, height = plotH)}

bm.plot <- ggplot(data = df.mi, aes(x=Simulated, y=Estimated, fill=best)) + 
  geom_tile() +
  scale_fill_distiller(palette = "Purples", direction = 1,
                       limit = c(0,10), space = "Lab",                      
                       name="Best model (lowest BIC)\nin 10 runs") +
  guides(fill = guide_colorbar(title.position = 'right', title.hjust = 0.5, 
                               frame.colour = NULL, barheight = 16, 
                               ticks.colour = 'black', ticks.linewidth = 0.5,  
                               draw.ulim = FALSE, draw.llim = FALSE)) +
  scale_x_continuous(breaks = c(1:12)) +
  scale_y_continuous(breaks = c(1:12)) +
  theme_classic() + 
  theme(axis.text.x = element_markdown(size = axtext),
        axis.text.y = element_markdown(size = axtext), 
        axis.title = element_text(size = axtitle), 
        legend.title = element_text(size = axtitle, angle = 90), 
        legend.text = element_text(size = axtext))

# bm.plot

# if (saveplots == 1) {dev.off()}

## plot model identifiability - reward sensitivity models

df.mi.rs <- read_csv("data/Model_identifiability_mle.csv", col_names = T)

df.mi.rs$Simulated_wrong <- df.mi.rs$Simulated
df.mi.rs$Estimated_wrong <- df.mi.rs$Estimated

for (n in 1:40) {
  w <- new[n]
  df.mi.rs$Simulated[df.mi.rs$Simulated_wrong == w] <- n
  df.mi.rs$Estimated[df.mi.rs$Estimated_wrong == w] <- n
}

# if (saveplots == 1) {tiff("R2R_output/Model_iden_bicp_rewsen.tiff", units="in", res = resolution, width = modplotW*2, height = plotH*2)}

bicp.rs.plot <- ggplot(data = df.mi.rs, aes(x=Simulated, y=Estimated, fill=bicp)) + 
  geom_tile() +
  scale_fill_distiller(palette = "Purples", direction = 1,
                       limit = c(0,100), 
                       space = "Lab",       
                       name="Percentage of simulated \nparticipants with lowest BIC") +
  guides(fill = guide_colorbar(title.position = 'right', title.hjust = 0.5, 
                               frame.colour = NULL, barheight = 16, 
                               ticks.colour = 'black', ticks.linewidth = 0.5,  
                               draw.ulim = FALSE, draw.llim = FALSE)) +
  scale_x_continuous(breaks = seq(from = 2, to = 40, by = 2)) +
  scale_y_continuous(breaks = seq(from = 2, to = 40, by = 2)) +
  theme_classic() + 
  theme(axis.text.x = element_markdown(size = (axtext-4)),
        axis.text.y = element_markdown(size = (axtext-4)), 
        axis.title = element_text(size = axtitle), 
        legend.title = element_text(size = axtitle, angle = 90), 
        legend.text = element_text(size = axtext))

# bicp.rs.plot

# if (saveplots == 1) {dev.off()}

# if (saveplots == 1) {tiff("R2R_output/Model_iden_bes_rewsent.tiff", units="in", res = resolution, width = modplotW*2, height = plotH*2)}

bm.rs.plot <- ggplot(data = df.mi.rs, aes(x=Simulated, y=Estimated, fill=best)) + 
  geom_tile() +
  scale_fill_distiller(palette = "Purples", direction = 1,
                       limit = c(0,10), space = "Lab",                      
                       name="Best model (lowest BIC)\nin 10 runs") +
  guides(fill = guide_colorbar(title.position = 'right', title.hjust = 0.5, 
                               frame.colour = NULL, barheight = 16, 
                               ticks.colour = 'black', ticks.linewidth = 0.5,  
                               draw.ulim = FALSE, draw.llim = FALSE)) +
  scale_x_continuous(breaks = seq(from = 2, to = 40, by = 2)) +
  scale_y_continuous(breaks = seq(from = 2, to = 40, by = 2)) +
  theme_classic() + 
  theme(axis.text.x = element_markdown(size = (axtext-4)),
        axis.text.y = element_markdown(size = (axtext-4)), 
        axis.title = element_text(size = axtitle), 
        legend.title = element_text(size = axtitle, angle = 90), 
        legend.text = element_text(size = axtext))

# bm.rs.plot

# if (saveplots == 1) {dev.off()}

```

```{r, warning=FALSE, message=FALSE, echo=FALSE, fig.height=plotH, fig.width=plotW}

## plot k parameters

d.k <- d %>% drop_na(k)

plt.data <- d.k %>%
  dplyr::group_by(Recipient) %>%
  dplyr::summarise(n = n(), median = median(k), .groups = "drop")

plt.data$original <- 0
plt.bootBias <- 0
plt.bootSE <- 0
plt.bootMed <- 0

for (r in plt.data$Recipient) {
  med.boot = boot(d.k$k[d.k$Recipient == r], function(x,i) median(x[i]), R=1000)
  med.boot <- summary(med.boot)
  for (col in colnames(med.boot)[2:ncol(med.boot)])
    plt.data[plt.data$Recipient == r, col] <- med.boot[1, col]
}

plt.data <- rename(plt.data, "k" = bootMed)

plot.k <- ggplot(d, aes(x = Recipient, y = k, fill = Recipient, 
                        color = Recipient, group = Recipient)) + 
  geom_bar(data = plt.data, stat = "identity", size = 0.5, alpha = 0.8, colour = 'black',
           position=position_dodge(0.5), width = 0.5) +
  geom_point(position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.5), 
             size = 2, alpha = 0.8, show.legend = FALSE) + 
  geom_bar(data = plt.data, stat = "identity", size = 0.5, alpha = 0, colour = 'black',
           position=position_dodge(0.5), width = 0.5) +
  geom_errorbar(data = plt.data, mapping = aes(x = Recipient, ymin = k - bootSE, ymax = k + bootSE), 
                colour = 'black', width = 0, position=position_dodge(0.5)) +
  scale_y_continuous(name = klabel, breaks = seq(0, 1.2, 0.2), limits = c(0, 1.2)) +
  scale_x_discrete(name = '') + 
  scale_fill_manual(values = otherselfcols) + 
  scale_color_manual(values = otherselfdots) + 
  theme_classic() + 
  theme(legend.position = 'none',
        axis.text=element_text(size = axtext),
        axis.text.x=element_text(size = axtext),
        axis.title.x = element_text(size = axtitle),
        axis.title.y = element_markdown(size = axtitle)) + 
  geom_signif(
    comparisons = list(c("Other", "Self")),
    map_signif_level = TRUE, test = "wilcox.test", colour = "black", tip_length = 0)

# if (saveplots == 1) {tiff('plotpanels/k_param.tiff', units="in", width = plotW, height = plotH, res = resolution)}

plot.k.save <- plot.k +
  annotation_custom(grob = textGrob("← More motivated", x=-0.75,  y=0.2, rot = 90,
                                    gp=gpar(fontsize=(axtext-4), fontface="italic"))) +
  annotation_custom(grob = textGrob("Less motivated →", x=-0.75,  y=0.8, rot = 90,
                                    gp=gpar(fontsize=(axtext-4), fontface="italic"))) +
  coord_cartesian(expand = T, clip = 'off')  +
  theme(plot.margin = unit(c(0, 0, 0, 1.5), "cm"))

# plot.k.save

# if (saveplots == 1) {dev.off()}

k.lab <- ggplot() +
  geom_textbox(mapping = aes(0.85, 0.25, 
                             label = "<span style='font-size:14pt'>← <i>More motivated</i><span>", text.color = "black", orientation = "left-rotated",
                             box.color = "white", hjust = 0, vjust = 0.5, halign = 0), width = unit(0.47, "npc")) +
  geom_textbox(mapping = aes(0.85, 0.85, 
                             label = "<span style='font-size:14pt'><i>Less motivated</i> →<span>", text.color = "black", orientation = "left-rotated",
                             box.color = "white", hjust = 0.9, vjust = 0.5, halign = 1), width = unit(0.47, "npc")) +
  xlim(0, 1) +
  theme_classic() +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.title.x = element_blank(),
        axis.line.x = element_blank(),
        axis.title.y = element_blank(),
        axis.line.y = element_blank())

plot.k <- plot_grid(k.lab, plot.k, NULL, ncol = 3)

```

```{r, warning=FALSE, message=FALSE, echo=FALSE, fig.height=plotH, fig.width=corrplotW}

## plot force

# if (saveplots == 1) {tiff("plotpanels/agent_by_effort_force.tiff", units="in", width = corrplotW, height = plotH, res = resolution)}

d.effort <- d.tbt.f %>% 
  group_by(ID, Recipient, Effort.r) %>% 
  summarise(Force_norm = mean(Force_norm)) %>% 
  mutate(Recipient = factor(Recipient, 
                            levels = c('Other', 'Self'))) # create data-frame of subject means

plot.effort.force <- ggplot(d.tbt.f, aes(x = Effort.r, y = Force_norm, group = Recipient, color = Recipient, fill = Recipient, linetype = Recipient)) + 
  geom_jitter(data = d.effort, position = position_jitterdodge(dodge.width = 0.35, jitter.height = 0, jitter.width = 0.1),
              shape = 21, size = 2.5, alpha = 0.8, stroke=0, show.legend = FALSE) +
  stat_smooth(alpha = 0.3, size = 0.2, show.legend = FALSE, formula = y ~ x, method = "lm") +
  stat_smooth(alpha = 0, size = 0.2, formula = y ~ x, method = "lm") +
  xlab('Effort level') + 
  scale_y_continuous(limits = c(0,1), name = "Force exerted<br>
        <span style='font-size:14pt'>(normalised AUC)</span>") +
  # ylab("Force exerted<br>
  #       <span style='font-size:14pt'>(normalised AUC)</span>") + 
  theme_classic() + 
  scale_color_manual(values = otherselfcols) + 
  scale_fill_manual(values = otherselfdots) +
  theme(legend.title = element_blank(),
        axis.text=element_text(size = axtext), 
        axis.title.x=element_text(size = axtitle),
        axis.title.y=element_markdown(size = axtitle),
        legend.text=element_text(size = axtext)) +
  guides(linetype = guide_legend(override.aes = list(size = 2))) 

# plot.effort.force

# if (saveplots == 1) {dev.off()}

# plot force-production by agent*reward

# if (saveplots == 1) {tiff("plotpanels/agent_by_reward_force.tiff", units="in", width = corrplotW, height = plotH, res = resolution)}

d.reward <- d.tbt.f %>% 
  group_by(ID, Recipient, Reward.r) %>% 
  summarise(Force_norm = mean(Force_norm)) %>% 
  mutate(Recipient = factor(Recipient, 
                            levels = c('Other', 'Self'))) # create data-frame of subject means

plot.reward.force <- ggplot(d.tbt.f, aes(x = Reward.r, y = Force_norm, group = Recipient, color = Recipient, fill = Recipient, linetype = Recipient)) + 
  geom_jitter(data = d.reward, position = position_jitterdodge(dodge.width = 0.35, jitter.height = 0, jitter.width = 0.1),
              shape = 21, size = 2.5, alpha = 0.8, stroke=0, show.legend = FALSE) +
  stat_smooth(alpha = 0.3, size = 0.2, show.legend = FALSE, formula = y ~ x, method = "lm") +
  stat_smooth(alpha = 0, size = 0.22, formula = y ~ x, method = "lm") +
  xlab('Reward level') + 
  scale_y_continuous(limits = c(0,1), name = "Force exerted<br>
        <span style='font-size:14pt'>(normalised AUC)</span>") +
  # ylab("Force exerted<br>
  # <span style='font-size:14pt'>(normalised AUC)</span>") + 
  theme_classic() + 
  scale_color_manual(values = otherselfcols) +
  scale_fill_manual(values = otherselfdots) +
  theme(legend.title = element_blank(),
        axis.text=element_text(size = axtext), 
        axis.title.x=element_text(size = axtitle),
        axis.title.y=element_markdown(size = axtitle),
        legend.text=element_text(size = axtext)) +
  guides(linetype = guide_legend(override.aes = list(size = 2))) 

# plot.reward.force

# if (saveplots == 1) {dev.off()}

```

## Figure 2

```{r, warning=FALSE, message=FALSE, echo=FALSE, fig.height=corrplotW*1.5, fig.width=corrplotW*1.5}

# combine plots from above

aligned <- align_plots(plot.effort.choice, plot.reward.choice, plot.rel.bic, h.plot, plot.effort.force, plot.reward.force, align = "hv", axis = "l")

plot.fig2 <- plot_grid(ggdraw(aligned[[1]]), ggdraw(aligned[[2]]), ggdraw(aligned[[3]]), win.mod, ggdraw(aligned[[4]]), plot.k, nrow = 3, ncol = 2, label_size = axtitle, labels = "AUTO", axis = "l")

plot.fig2 <- ggdraw(plot.fig2) +
  draw_plot(plot.prop.bic, x = .36, y = .57, hjust = 0.5, vjust = 0.5, width = 0.13, height = 0.13) +
  draw_line(x = c(0.31, 0.34), y = c(0.49, 0.52), color = "#203964", size = 2) +
  draw_line(x = c(0.41, 0.38), y = c(0.49, 0.52), color = "#7031A0", size = 2)

if (saveplots == 1) {tiff("figures/Figure2.tiff", units="in", width = corrplotW*1.5, height = corrplotW*1.5, res = resolution)}

plot.fig2

if (saveplots == 1) {dev.off()}

```

**Figure 2. Choices and computational modelling of prosocial and self-benefitting decisions.**

## Figure 3

```{r, warning=FALSE, message=FALSE, echo=FALSE, fig.height=corrplotW*0.5, fig.width=corrplotW*1.5}

# combine plots from above

plot.fig3 <- plot_grid(ggdraw(aligned[[5]]), ggdraw(aligned[[6]]), ncol = 2, label_size = axtitle, labels = "AUTO", axis = "l")

if (saveplots == 1) {tiff("figures/Figure3.tiff", units="in", width = corrplotW*1.5, height = corrplotW*0.5, res = resolution)}

plot.fig3

if (saveplots == 1) {dev.off()}
```
**Figure 3. Force exerted as a function of effort level and reward level for self and other.**

## RSA analysis

```{r warning=FALSE, message=FALSE, echo=FALSE}

set.seed(1357) # make it reproducible

nSubs <- length(Models[[1]])                    # number of ppts
ntrials  <- 50                                  # n of trials, each repeated 4x
ntrialsSO <- 25
session<-1                                      # number of sessions

roi<-c('TPJ', 'ACCg', 'AI', 'dACC', 'vmPFC', 'VS') # names of ROIs

model_names <- c('selfOther', 'sV', 'eff', 'rew') # names of models    

# set up blank lists to fill in loops

brainRDMmean <- vector(mode='list', length=length(roi))
Models.mean <- vector(mode='list', length=length(model_names))
modelvec <- vector(mode='list', length=length(model_names))
brainvec <- vector(mode='list', length=length(roi))
rs.roi <- vector(mode='list', length=length(roi))
brainRDMself <- vector(mode='list', length=length(roi))
brainRDMother <- vector(mode='list', length=length(roi))
Models.self <- vector(mode='list', length=length(model_names))
Models.other <- vector(mode='list', length=length(model_names))
modelvec.self <- vector(mode='list', length=length(model_names))
modelvec.other <- vector(mode='list', length=length(model_names))
brainvecSelf <- vector(mode='list', length=length(roi))
brainvecOther <- vector(mode='list', length=length(roi))
rs.roi.self <- vector(mode='list', length=length(roi))
rs.roi.other <- vector(mode='list', length=length(roi))

# 1a. get average brain RDM - put cells in 3dim matrix and average

for (iroi in 1:length(roi)){
  curM <- array(NA, dim=c(nSubs,ntrials,ntrials))
  for (is in 1:nSubs){
    curM[is, 1:ntrials, 1:ntrials] <- brainRDM[[iroi]][[is]][[1]]
  }
  brainRDMmean[[iroi]] <- apply(curM, c(2,3), mean)
}

# 1b. the same for behaviour, but only necessary for sV model because this is the only one that differs across subjects

for (im in 1:length(model_names)){
  curM <- array(NA, dim=c(nSubs,ntrials,ntrials))
  for (is in 1:nSubs){
    curM[is, 1:ntrials, 1:ntrials] <- Models[[im]][[is]][[1]]
  }
  Models.mean[[im]] <- apply(curM, c(2,3), mean)
}

# 1c. Take self and other seperately

for (iroi in 1:length(roi)){
  brainRDMself[[iroi]] <- vector(mode='list', length=length(nSubs))
  brainRDMother[[iroi]]<- vector(mode='list', length=length(nSubs))
  for (is in 1:nSubs){
    brainRDMself[[iroi]][[is]] <- vector(mode='list', length=1)
    brainRDMother[[iroi]][[is]] <- vector(mode='list', length=1)
    brainRDMself[[iroi]][[is]][[1]] <- array(NA, dim=c((ntrials/2),(ntrials/2)))
    brainRDMother[[iroi]][[is]][[1]] <- array(NA, dim=c((ntrials/2),(ntrials/2)))
    brainRDMself[[iroi]][[is]][[1]][1:(ntrials/2), 1:(ntrials/2)] <- brainRDM[[iroi]][[is]][[1]][1:25,1:25]
    brainRDMother[[iroi]][[is]][[1]][1:(ntrials/2), 1:(ntrials/2)] <- brainRDM[[iroi]][[is]][[1]][26:50,26:50]
  }
}

# 1d. Take self and other models seperately

for (im in 1:length(model_names)){
  
  Models.self[[im]] <- vector(mode='list', length=length(model_names))
  Models.other[[im]] <- vector(mode='list', length=length(model_names))
  
  for (is in 1:nSubs){
    
    Models.self[[im]][[is]] <- vector(mode='list', length=1)
    Models.other[[im]][[is]] <- vector(mode='list', length=1)
    Models.self[[im]][[is]][[1]] <- array(NA, dim=c((ntrials/2),(ntrials/2)))
    Models.other[[im]][[is]][[1]] <- array(NA, dim=c((ntrials/2),(ntrials/2)))
    Models.self[[im]][[is]][[1]][1:(ntrials/2), 1:(ntrials/2)]   <- Models[[im]][[is]][[1]][1:25,1:25]
    Models.other[[im]][[is]][[1]][1:(ntrials/2), 1:(ntrials/2)] <- Models[[im]][[is]][[1]][26:50,26:50]
  }
  
}

## get correlation values for full templates. Squareform puts values in a square matrix

ps <- array(NA, dim = c(length(model_names), length(roi)), dimnames = list(model_names, roi))
stats <- array(NA, dim = c(length(model_names), length(roi)), dimnames = list(model_names, roi))

for (region in 1:length(roi)){
  rs.roi[[region]] <- array(0, dim = c(nSubs,length(model_names)))
  for (m in 1:length(model_names)){
    for (s in 1:nSubs){
      modelvec[[region]] <- squareform(Models[[m]][[s]][[1]])         
      brainvec[[region]] <- squareform(brainRDM[[region]][[s]][[1]])
      rs.roi[[region]][s,m] <- KTA(brainvec[[region]], modelvec[[region]])
    }
    wil <- wilcox.test(rs.roi[[region]][,m], alternative = "g")
    ps[m,region] <- wil$p.value
    stats[m,region] <- wil$statistic
  }
}

### get correlation values for self/other only. Uses kendalls tau a to
### relate brain RDM and behaviour RDM

ps.self <- array(NA, dim = c(length(model_names), length(roi)), dimnames = list(model_names, roi))
stats.self <- array(NA, dim = c(length(model_names), length(roi)), dimnames = list(model_names, roi))
zs.self <- array(NA, dim = c(length(model_names), length(roi)), dimnames = list(model_names, roi))
mean.self <- array(NA, dim = c(length(model_names), length(roi)), dimnames = list(model_names, roi))
sem.self <- array(NA, dim = c(length(model_names), length(roi)), dimnames = list(model_names, roi))
ps.other <- array(NA, dim = c(length(model_names), length(roi)), dimnames = list(model_names, roi))
stats.other <- array(NA, dim = c(length(model_names), length(roi)), dimnames = list(model_names, roi))
zs.other <- array(NA, dim = c(length(model_names), length(roi)), dimnames = list(model_names, roi))
mean.other <- array(NA, dim = c(length(model_names), length(roi)), dimnames = list(model_names, roi))
sem.other <- array(NA, dim = c(length(model_names), length(roi)), dimnames = list(model_names, roi))
ps.comp <- array(NA, dim = c(length(model_names), length(roi)), dimnames = list(model_names, roi))
stats.comp <- array(NA, dim = c(length(model_names), length(roi)), dimnames = list(model_names, roi))
zs.comp <- array(NA, dim = c(length(model_names), length(roi)), dimnames = list(model_names, roi))

for (region in 1:length(roi)){
  rs.roi.self[[region]] <- array(0, dim = c(nSubs,length(model_names)))
  rs.roi.other[[region]] <- array(0, dim = c(nSubs,length(model_names)))
  for (m in 1:length(model_names)){
    for (s in 1:nSubs){
      modelvec.self[[region]]  <- squareform(Models.self[[m]][[s]][[1]])
      modelvec.other[[region]] <- squareform(Models.other[[m]][[s]][[1]])  
      brainvecSelf[[region]]   <- squareform(brainRDMself[[region]][[s]][[1]])
      brainvecOther[[region]]  <- squareform(brainRDMother[[region]][[s]][[1]])
      rs.roi.self[[region]][s,m] <- KTA(brainvecSelf[[region]], modelvec.self[[region]])
      rs.roi.other[[region]][s,m] <- KTA(brainvecOther[[region]], modelvec.other[[region]]) 
    }
    if (m > 1){
      # Wilcoxon one-sided signed rank test of Kendall's tau for self > 0
      wil.self <- wilcox.test(rs.roi.self[[region]][,m], alternative = "g")
      ps.self[m,region] <- wil.self$p.value
      stats.self[m,region] <- wil.self$statistic
      zs.self[m,region] <- qnorm(wil.self$p.value/2)
      mean.self[m,region] <- mean(rs.roi.self[[region]][,m])
      sem.self[m,region] <- std_err(rs.roi.self[[region]][,m])
      # Wilcoxon one-sided signed rank test of Kendall's tau for other > 0
      wil.other <- wilcox.test(rs.roi.other[[region]][,m], alternative = "g")
      ps.other[m,region] <- wil.other$p.value
      stats.other[m,region] <- wil.other$statistic
      zs.other[m,region] <- qnorm(wil.other$p.value/2)
      mean.other[m,region] <- mean(rs.roi.other[[region]][,m])
      sem.other[m,region] <- std_err(rs.roi.other[[region]][,m])
      # Wilcoxon two-sided signed rank test between self and other RDM correlations
      wil.comp <- wilcox.test(rs.roi.self[[region]][,m], rs.roi.other[[region]][,m], paired = T)
      ps.comp[m,region] <- wil.comp$p.value
      stats.comp[m,region] <- wil.comp$statistic
      zs.comp[m,region] <- qnorm(wil.comp$p.value/2)
    }
  }
}

d.wide <- read.csv('data/PM_fmri_questionnaire_wo_excluded_totals_share.csv') %>% # reset data 
  rename('difference_k' = other_k_self_k, 
         'other_k' = other_K, 
         'self_ACCg_pattern' = ACCg_pattern_self, 
         'other_ACCg_pattern' = ACCg_pattern_other,
         'self_TPJ_force' = TPJ_Self_force,
         'other_TPJ_force' = TPJ_Other_force,
         'other_ACCg_force' = other_Accg_force,
         'self_midbrain_sV_RSA' = self_midbrain_WB_RSA,
         'other_midbrain_sV_RSA' = other_midbrain_WB_RSA)

# add results to main dataframe

for (region in 1:length(roi)){
  for (m in 1:length(model_names)){
    selfcol <- rs.roi.self[[region]][ ,m]
    othercol <- rs.roi.other[[region]][ ,m]
    eval(parse(text = paste0('d.wide$self_',roi[region], '_', model_names[m], '_RSA <- selfcol')))
    eval(parse(text = paste0('d.wide$other_',roi[region], '_', model_names[m], '_RSA <- othercol')))
  }
}

d <- d.wide %>% 
  pivot_longer(cols = starts_with(c('self','other')), 
               names_to = c('Recipient', '.value'),
               names_pattern = '(self|other)_(.*)')           %>% # transform to long-format
  mutate(Recipient = factor(Recipient, 
                            levels = c('other', 'self'), 
                            labels = c('Other', 'Self')))     %>% # recode agent as factor
  mutate(ID = factor(scanningID))                                 # recode subject ID as factor

# put mean tau values, standard error mean, and p values into long format separately for self and other

mean.s <- as.data.frame(mean.self) %>% 
  drop_na() %>% 
  rownames_to_column(var = "Measure") %>% 
  add_column(Recipient = "Self", .before = 1)
mean.o <- as.data.frame(mean.other) %>% 
  drop_na() %>% 
  rownames_to_column(var = "Measure") %>% 
  add_column(Recipient = "Other", .before = 1)

sem.s <- as.data.frame(sem.self) %>% 
  drop_na() %>% 
  rownames_to_column(var = "Measure") %>% 
  mutate(Recipient = "Self")
sem.o <- as.data.frame(sem.other) %>% 
  drop_na() %>% 
  rownames_to_column(var = "Measure") %>% 
  mutate(Recipient = "Other")

ps.s <- as.data.frame(ps.self) %>% 
  drop_na() %>% 
  rownames_to_column(var = "Measure") %>% 
  add_column(Recipient = "Self", .before = 1)
ps.o <- as.data.frame(ps.other) %>% 
  drop_na() %>% 
  rownames_to_column(var = "Measure") %>% 
  add_column(Recipient = "Other", .before = 1)

# combine mean tau values, standard error mean, and p values for self and other

mean.so <- bind_rows(mean.s, mean.o) %>% 
  pivot_longer(cols = !contains(c("Recipient", "Measure")), names_to = 'Area', values_to = 'mean') %>% 
  mutate(Recipient = factor(Recipient, 
                            levels = c('Other', 'Self'), 
                            labels = c('Other', 'Self')))

sem.so <- bind_rows(sem.s, sem.o) %>% 
  pivot_longer(cols = !contains(c("Recipient", "Measure")), names_to = 'Area', values_to = 'sem') %>% 
  mutate(Recipient = factor(Recipient, 
                            levels = c('Other', 'Self'), 
                            labels = c('Other', 'Self'))) 

p.kend <- bind_rows(ps.s, ps.o) %>% 
  pivot_longer(cols = !contains(c("Recipient", "Measure")), names_to = 'Area', values_to = 'pval') %>% 
  mutate(Recipient = factor(Recipient, 
                            levels = c('Other', 'Self'), 
                            labels = c('Other', 'Self'))) %>%
  mutate(pvalFDR = NA) # correct p values

# correct p values for 4 main ROIs
p.kend$pvalFDR[p.kend$Area == "TPJ" | p.kend$Area == "ACCg" | p.kend$Area == "AI" | p.kend$Area == "dACC"] <- p.adjust(p.kend$pval[p.kend$Area == "TPJ" | p.kend$Area == "ACCg" | p.kend$Area == "AI" | p.kend$Area == "dACC"], method = "fdr")

# correct p values for 2 supplementary ROIs
p.kend$pvalFDR[p.kend$Area == "vmPFC" | p.kend$Area == "VS"] <- 
  p.adjust(p.kend$pval[p.kend$Area == "vmPFC" | p.kend$Area == "VS"], method = "fdr")

mean.sem.so <- left_join(mean.so, sem.so, by = c("Measure", "Recipient", "Area"))
p.kend <- left_join(mean.sem.so, p.kend, by = c("Measure", "Recipient", "Area"))

p.diff <-
  as.data.frame(ps.comp) %>%
  drop_na() %>%
  rownames_to_column(var = "Measure") %>%
  pivot_longer(cols = !Measure, names_to = 'Area', values_to = 'pval') %>%
  mutate(pvalFDR = NA) %>% 
  add_column("Contrast" = "Self vs. other", .before = "Measure")

# correct p values for 4 main ROIs
p.diff$pvalFDR[p.diff$Area == "TPJ" | p.diff$Area == "ACCg" | p.diff$Area == "AI" | p.diff$Area == "dACC"] <- p.adjust(p.diff$pval[p.diff$Area == "TPJ" | p.diff$Area == "ACCg" | p.diff$Area == "AI" | p.diff$Area == "dACC"], method = "fdr")

# correct p values for 2 supplementary ROIs
p.diff$pvalFDR[p.diff$Area == "vmPFC" | p.diff$Area == "VS"] <- 
  p.adjust(p.diff$pval[p.diff$Area == "vmPFC" | p.diff$Area == "VS"], method = "fdr")

# Wilcoxon signed-rank test on ACCg effort Kendall's tau for self and other

wilcox.es.accg.eff <- wilcox_effsize(d, ACCg_eff_RSA ~ Recipient, paired = T, ci = T)
Zstat.accg.eff <- qnorm(p.diff$pval[p.diff$Measure == "eff" & p.diff$Area == "ACCg"]/2)

d.rsa.corr <- d.wide %>% 
  select(contains("RSA")) %>% 
  select(contains("self_") | contains ("other_")) %>% 
  select(!contains(c("selfOther", "midbrain", "VS", "vmPFC")))

d.rsa.corr$otherself_ACCg_eff_RSA <- d.rsa.corr$other_ACCg_eff_RSA - d.rsa.corr$self_ACCg_eff_RSA

rsa.corr <- corr.test(d.rsa.corr)
rsa.corr.r <- rsa.corr[["r"]]
rsa.corr.r[rsa.corr[["p"]] > 0.05] <- NA

rsa.corr.r <- cbind(rownames(rsa.corr.r), data.frame(rsa.corr.r, row.names=NULL))

write_csv(rsa.corr.r, file = "data/RSA_correlations_p0.05.csv", na = "")

## "connectivity" analysis - correlations between ACCg other RDM & dACC / AI for other / self RDMs

ps.self.accg <- array(NA, dim = c(1, 2), dimnames = list("connectivity", roi[3:4]))
stats.self.accg <- array(NA, dim = c(1, 2), dimnames = list("connectivity", roi[3:4]))
zs.self.accg <- array(NA, dim = c(1, 2), dimnames = list("connectivity", roi[3:4]))
mean.self.accg <- array(NA, dim = c(1, 2), dimnames = list("connectivity", roi[3:4]))
sem.self.accg <- array(NA, dim = c(1, 2), dimnames = list("connectivity", roi[3:4]))

ps.other.accg <- array(NA, dim = c(1, 2), dimnames = list("connectivity", roi[3:4]))
stats.other.accg <- array(NA, dim = c(1, 2), dimnames = list("connectivity", roi[3:4]))
zs.other.accg <- array(NA, dim = c(1, 2), dimnames = list("connectivity", roi[3:4]))
mean.other.accg <- array(NA, dim = c(1, 2), dimnames = list("connectivity", roi[3:4]))
sem.other.accg <- array(NA, dim = c(1, 2), dimnames = list("connectivity", roi[3:4]))

ps.comp.accg <- array(NA, dim = c(1, 2), dimnames = list("connectivity", roi[3:4]))
stats.comp.accg <- array(NA, dim = c(1, 2), dimnames = list("connectivity", roi[3:4]))
zs.comp.accg <- array(NA, dim = c(1, 2), dimnames = list("connectivity", roi[3:4]))

rs.self.accg <- vector(mode='list', length=2)
rs.other.accg <- vector(mode='list', length=2)
wilcox.es.accg <- data.frame()

if (roi[2] == "ACCg" & roi[3] == "AI" & roi[4] == "dACC"){ # make sure indexes assumed below are right
  
  for (region in 3:4){
    
    rs.self.accg[[region-2]] <- array(0, dim = c(nSubs,1))
    rs.other.accg[[region-2]] <- array(0, dim = c(nSubs,1))
    
    for (s in 1:nSubs){
      brainvecOtherACCg  <- squareform(brainRDMother[[2]][[s]][[1]])
      brainvecSelf[[region-2]]   <- squareform(brainRDMself[[region]][[s]][[1]])
      brainvecOther[[region-2]]  <- squareform(brainRDMother[[region]][[s]][[1]])
      rs.self.accg[[region-2]][s,1] <- KTA(brainvecOtherACCg, brainvecSelf[[region-2]])
      rs.other.accg[[region-2]][s,1] <- KTA(brainvecOtherACCg, brainvecOther[[region-2]]) 
    }
    
    RSA <- c(rs.self.accg[[region-2]], rs.other.accg[[region-2]])
    Recipient <- c(rep(1,length(rs.self.accg[[region-2]])), rep(2,length(rs.other.accg[[region-2]]))) 
    d.accg <- data.frame(RSA, Recipient) %>% 
      mutate(Recipient = as.factor(Recipient))
    
    # Wilcoxon one-sided signed rank test of Kendall's tau for self > 0
    wil.self.accg <- wilcox.test(rs.self.accg[[region-2]][,1], alternative = "g")
    ps.self.accg[[1,region-2]] <- wil.self.accg$p.value
    stats.self.accg[[1,region-2]] <- wil.self.accg$statistic
    zs.self.accg[[1,region-2]] <- qnorm(wil.self.accg$p.value/2)
    mean.self.accg[[1,region-2]] <- mean(rs.self.accg[[region-2]][,1])
    sem.self.accg[[1,region-2]] <- std_err(rs.self.accg[[region-2]][,1])
    # Wilcoxon one-sided signed rank test of Kendall's tau for other > 0
    wil.other.accg <- wilcox.test(rs.other.accg[[region-2]][,1], alternative = "g")
    ps.other.accg[[1,region-2]] <- wil.other.accg$p.value
    stats.other.accg[[1,region-2]] <- wil.other.accg$statistic
    zs.other.accg[[1,region-2]] <- qnorm(wil.other.accg$p.value/2)
    mean.other.accg[[1,region-2]] <- mean(rs.other.accg[[region-2]][,1])
    sem.other.accg[[1,region-2]] <- std_err(rs.other.accg[[region-2]][,1])
    # Wilcoxon two-sided signed rank test between self and other RDM correlations
    wil.comp.accg <- wilcox.test(rs.self.accg[[region-2]][,1], rs.other.accg[[region-2]][,1], paired = T)
    ps.comp.accg[[1,region-2]] <- wil.comp.accg$p.value
    stats.comp.accg[[1,region-2]] <- wil.comp.accg$statistic
    zs.comp.accg[[1,region-2]] <- qnorm(wil.comp.accg$p.value/2)
    wil.es.accg <- wilcox_effsize(d.accg, RSA ~ Recipient, paired = T, ci = T)
    wil.es.accg$Area <- roi[region]
    wilcox.es.accg <- bind_rows(wilcox.es.accg, wil.es.accg)
  }
  
}

## effort vs. reward analysis - comparison between effort and reward RDMs in vmPFC / VS for self / other

ps.self.reweff.comp <- array(NA, dim = c(1, 2), dimnames = list("effrew", roi[5:6]))
stats.self.reweff.comp <- array(NA, dim = c(1, 2), dimnames = list("effrew", roi[5:6]))
zs.self.reweff.comp <- array(NA, dim = c(1, 2), dimnames = list("effrew", roi[5:6]))

ps.other.reweff.comp <- array(NA, dim = c(1, 2), dimnames = list("effrew", roi[5:6]))
stats.other.reweff.comp <- array(NA, dim = c(1, 2), dimnames = list("effrew", roi[5:6]))
zs.other.reweff.comp <- array(NA, dim = c(1, 2), dimnames = list("effrew", roi[5:6]))

wilcox.es.self.reweff <- data.frame()
wilcox.es.other.reweff <- data.frame()

if (roi[5] == "vmPFC" & roi[6] == "VS" & model_names[3] == "eff" & model_names[4] == "rew"){ # make sure indexes assumed below are right
  
  for (region in 5:6){
    
    # Wilcoxon two-sided signed rank test between effort and reward RDM correlations for self and other
    wil.self.reweff.comp <- wilcox.test(rs.roi.self[[region]][,3], rs.roi.self[[region]][,4], paired = T)
    ps.self.reweff.comp[1,region-4] <- wil.self.reweff.comp$p.value
    stats.self.reweff.comp[1,region-4] <- wil.self.reweff.comp$statistic
    zs.self.reweff.comp[1,region-4] <- qnorm(wil.self.reweff.comp$p.value/2)
    
    RSA.self <- c(rs.roi.self[[region]][,3], rs.roi.self[[region]][,4])
    Measure <- c(rep(3,length(rs.roi.self[[region]][,3])), rep(4,length(rs.roi.self[[region]][,4]))) 
    d.self.reweff <- data.frame(RSA.self, Measure) %>% 
      mutate(Measure = as.factor(Measure))
    
    wil.es.self.reweff <- wilcox_effsize(d.self.reweff, RSA.self ~ Measure, paired = T, ci = T)
    wil.es.self.reweff$Area <- roi[region]
    wilcox.es.self.reweff <- bind_rows(wilcox.es.self.reweff, wil.es.self.reweff)
    
    wil.other.reweff.comp <- wilcox.test(rs.roi.other[[region]][,3], rs.roi.other[[region]][,4], paired = T)
    ps.other.reweff.comp[1,region-4] <- wil.other.reweff.comp$p.value
    stats.other.reweff.comp[1,region-4] <- wil.other.reweff.comp$statistic
    zs.other.reweff.comp[1,region-4] <- qnorm(wil.other.reweff.comp$p.value/2)
    
    RSA.other <- c(rs.roi.other[[region]][,3], rs.roi.other[[region]][,4])
    Measure <- c(rep(3,length(rs.roi.other[[region]][,3])), rep(4,length(rs.roi.other[[region]][,4]))) 
    d.other.reweff <- data.frame(RSA.other, Measure) %>% 
      mutate(Measure = as.factor(Measure))
    
    wil.es.other.reweff <- wilcox_effsize(d.other.reweff, RSA.other ~ Measure, paired = T, ci = T)
    wil.es.other.reweff$Area <- roi[region]
    wilcox.es.other.reweff <- bind_rows(wilcox.es.other.reweff, wil.es.other.reweff)
    
  }
  
}

p.self.diff <-
  as.data.frame(ps.self.reweff.comp) %>%
  drop_na() %>%
  mutate("Measure" = "self") %>%
  pivot_longer(cols = !Measure, names_to = 'Area', values_to = 'pval') %>%
  add_column("Contrast" = "Reward vs. effort", .before = "Measure")

z.self.diff <-
  as.data.frame(zs.self.reweff.comp) %>%
  drop_na() %>%
  mutate("Measure" = "self") %>%
  pivot_longer(cols = !Measure, names_to = 'Area', values_to = 'Z') %>%
  add_column("Contrast" = "Reward vs. effort", .before = "Measure")

wilcox.es.self.reweff <- wilcox.es.self.reweff %>% 
    mutate("Measure" = "self") %>%
  add_column("Contrast" = "Reward vs. effort", .before = "Measure")

p.other.diff <-
  as.data.frame(ps.other.reweff.comp) %>%
  drop_na() %>%
  mutate("Measure" = "other") %>%
  pivot_longer(cols = !Measure, names_to = 'Area', values_to = 'pval') %>%
  add_column("Contrast" = "Reward vs. effort", .before = "Measure")

z.other.diff <-
  as.data.frame(zs.other.reweff.comp) %>%
  drop_na() %>%
  mutate("Measure" = "other") %>%
  pivot_longer(cols = !Measure, names_to = 'Area', values_to = 'Z') %>%
  add_column("Contrast" = "Reward vs. effort", .before = "Measure")

wilcox.es.other.reweff <- wilcox.es.other.reweff %>% 
    mutate("Measure" = "other") %>%
  add_column("Contrast" = "Reward vs. effort", .before = "Measure")

p.reweff.diff <- left_join(bind_rows(z.self.diff, z.other.diff), bind_rows(wilcox.es.self.reweff, wilcox.es.other.reweff) %>% select("Contrast", "Measure", "Area", "effsize", "conf.low", "conf.high"))

p.reweff.diff <- left_join(p.reweff.diff, bind_rows(p.self.diff, p.other.diff))

```

```{r, warning=FALSE, message=FALSE, echo=FALSE, fig.height=plotH, fig.width=plotW}

## plot RSA data

areas <- c("ACCg", 
           "dACC", 
           "AI",
           "midbrain")

measures <- c("Effort", 
              "SV",
              "SV",
              "SV")

rsatitles <- c("ACCg",
               "dACC/dmPFC",
               "AI",
               "VTA")

rsaylabs <- c(taulabel,
              taulabel,
              taulabel,
              paramestlab)

rsaymin <- c(-0.1, -0.1, -0.1, NA)
rsaymax <- c(0.16, 0.3, 0.3, NA)

toplot <- data.frame(areas, measures)

d.rsa <- d %>% pivot_longer(cols = ends_with(c('eff_RSA','rew_RSA', 'sV_RSA')), 
                            names_to = c('Area', 'Measure'),
                            names_sep = '_') %>% 
  mutate(Measure = factor(Measure, levels = c('eff', 'rew', 'sV'), labels = c('Effort', 'Reward', 'SV'))) %>% 
  subset(Measure != 'Reward')

mid.self.t <- t.test(d.rsa$value[d.rsa$Area == "midbrain" & d.rsa$Recipient == "Self"])
mid.other.t <- t.test(d.rsa$value[d.rsa$Area == "midbrain" & d.rsa$Recipient == "Other"])
mid.diff.t <- t.test(d.rsa$value[d.rsa$Area == "midbrain" & d.rsa$Recipient == "Other"],
                     d.rsa$value[d.rsa$Area == "midbrain" & d.rsa$Recipient == "Self"], paired = TRUE)

stars <- p.kend %>% 
  add_row(Recipient = "Self", Measure = "sV", Area = "midbrain", pval = mid.self.t$p.value, pvalFDR = p.adjust(c(mid.self.t$p.value, mid.other.t$p.value), method = "fdr")[1]) %>% 
  add_row(Recipient = "Other", Measure = "sV", Area = "midbrain", pval = mid.other.t$p.value, pvalFDR = p.adjust(c(mid.self.t$p.value, mid.other.t$p.value), method = "fdr")[2]) %>% 
  mutate(Measure = factor(Measure, levels = c('eff', 'rew', 'sV'), labels = c('Effort', 'Reward', 'SV'))) %>% 
  mutate(Recipient = factor(Recipient)) %>% 
  mutate(label = "") %>% 
  mutate(value = NA)

stars$label[stars$pvalFDR < 0.05] <- "*"
stars$label[stars$pvalFDR < 0.01] <- "**"
stars$label[stars$pvalFDR < 0.001] <- "***"

stars$value[stars$Measure == "Effort" & stars$pvalFDR < 0.05] <- 0.12
stars$value[stars$Measure == "SV" & stars$pvalFDR < 0.05] <- 0.2

stars.diff <- p.diff %>% 
  add_row(Measure = "sV", Area = "midbrain", pval = mid.diff.t$p.value, pvalFDR = mid.diff.t$p.value) %>% 
  mutate(Measure = factor(Measure, levels = c('eff', 'rew', 'sV'), labels = c('Effort', 'Reward', 'SV'))) %>% 
  mutate(label = "")

stars.diff$label[stars.diff$pvalFDR < 0.05] <- "*"
stars.diff$label[stars.diff$pvalFDR < 0.01] <- "**"
stars.diff$label[stars.diff$pvalFDR < 0.001] <- "***"

for (p in 1:nrow(toplot)){
  
  measure <- as.character(toplot$measures[p])
  area <- as.character(toplot$areas[p])
  
  d.rsa.plot <- d.rsa %>% filter(Measure == measure & Area == area) %>% droplevels()
  
  # if (saveplots == 1) {tiff(paste0('plotpanels/RSA_',measure,'_',area,'.tiff'), units="in", width = plotW, height = plotH, res = resolution)}
  
  plot.rsa <- ggplot(d.rsa.plot, aes(x = Recipient, y = value, fill = Recipient, 
                                     color = Recipient)) + 
    stat_summary(fun = mean, size = 0.5, geom = 'bar', alpha = 0.8, colour = 'black',
                 position=position_dodge(0.5), width = 0.5) +
    geom_point(position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.5), 
               size = 2, alpha = 0.8, show.legend = FALSE) + 
    stat_summary(fun = mean, size = 0.5, geom = 'bar', alpha = 0, colour = 'black',
                 position=position_dodge(0.5), width = 0.5) +
    stat_summary(fun.data = mean_se, geom = 'errorbar', colour = 'black', width = 0, position=position_dodge(0.5)) + 
    scale_y_continuous(name = rsaylabs[p], limits = c(rsaymin[p], rsaymax[p]), n.breaks = 6) +
    scale_x_discrete(name = '') + 
    scale_fill_manual(values = otherselfcols) + 
    scale_color_manual(values = otherselfdots) + 
    ggtitle(rsatitles[p]) +
    theme_classic() + 
    theme(legend.position = 'none',
          axis.text.y=element_text(size = axtext),
          axis.text.x=element_text(size = axtext),
          axis.title.y=element_markdown(size = axtitle),
          plot.title = element_text(size = axtitle, hjust = 0.5), 
          plot.background = element_rect(fill = NA, colour = NA)) 
  
  stars.plot <- stars %>% filter(Measure == measure & Area == area) %>% droplevels()
  stars.diff.plot <- stars.diff %>% filter(Measure == measure & Area == area) %>% droplevels()
  
  plot.rsa <- plot.rsa +
    geom_text(data = stars.plot, label = stars.plot$label, 
              position = position_dodge(0.5), 
              colour = 'black', size = 5) 
  
  if (stars.diff.plot$pvalFDR < 0.05){
    
    plot.rsa <- plot.rsa +
      geom_signif(comparisons = list(c("Other", "Self")), map_signif_level = FALSE, colour = "black", 
                  tip_length = 0, test = NULL, annotations = stars.diff.plot$label)
  }
  
  # print(plot.rsa)
  
  plot.name <- paste0("plot.",measure,".", area)
  
  assign(plot.name, plot.rsa)
  
  # if (saveplots == 1) {dev.off()}
}

```

```{r, warning=FALSE, message=FALSE, echo=FALSE, fig.height=plotH, fig.width=plotW}

## plot univariate

toplot.univ <- c("ACCg_force", 
                 "dacc_dmpfc_svc_conj", 
                 "AI_conj_SVC", 
                 "AI_SV_svc")
heights <- c(1.3, 0.5, 0.25, 0.5)
univtitles <- c("ACCg",
                "dACC/dmPFC",
                "AI",
                "vAI")

for (p in 1:length(toplot.univ)){
  
  d2 <- d
  
  univ <- toplot.univ[p]
  
  colnames(d2)[colnames(d2) == univ] <- "value"
  
  univ.self.t <- t.test(d2$value[d2$Recipient == "Self"])
  univ.other.t <- t.test(d2$value[d2$Recipient == "Other"])
  
  univ.diff.t <- t.test(d2$value[d2$Recipient == "Other"], d2$value[d2$Recipient == "Self"], paired = TRUE)
  
  if (univ.self.t$p.value < 0.05) {star.self <- "*"
  } else if (univ.self.t$p.value < 0.01) {star.self <- "**"
  } else if (univ.self.t$p.value < 0.001) {star.self <- "***"
  } else {star.self <- ""}
  if (univ.other.t$p.value < 0.05) {star.other <- "*"
  } else if (univ.other.t$p.value < 0.01) {star.other <- "**"
  } else if (univ.other.t$p.value < 0.001) {star.other <- "***"
  } else {star.other <- ""}
  if (univ.diff.t$p.value < 0.05) {star.diff <- "*"
  } else if (univ.diff.t$p.value < 0.01) {star.diff <- "**"
  } else if (univ.diff.t$p.value < 0.001) {star.diff <- "***"
  } else {star.diff <- ""}
  
  stars.plot.univ <- data.frame(Recipient = c("Other", "Self"), value = c(heights[p], heights[p]), label = c(star.other, star.self))
  
  # if (saveplots == 1) {tiff(paste0('plotpanels/Univariate_',univ,'.tiff'), units="in", width = plotW, height = plotH, res = resolution)}
  
  plot.univ <- ggplot(d2, aes(x = Recipient, y = value, fill = Recipient, 
                              color = Recipient, group = Recipient)) +
    stat_summary(fun.y = mean, size = 0.5, geom = 'bar', alpha = 0.8, colour = 'black',
                 position=position_dodge(0.5), width = 0.5) +
    geom_point(position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.5), 
               size = 2, alpha = 0.8, show.legend = FALSE) + 
    stat_summary(fun.y = mean, size = 0.5, geom = 'bar', alpha = 0.0, colour = 'black',
                 position=position_dodge(0.5), width = 0.5) +
    stat_summary(fun.data = mean_se, geom = 'errorbar', colour = 'black', width = 0, position=position_dodge(0.5)) +
    scale_y_continuous(name = paramestlab, n.breaks = 6) +
    scale_x_discrete(name = '') + 
    scale_fill_manual(values = otherselfcols) + 
    scale_color_manual(values = otherselfdots) + 
    theme_classic() + 
    theme(legend.position = 'none',
          axis.text=element_text(size = axtext),
          axis.text.x=element_text(size = axtext),
          axis.title=element_text(size = axtitle),
          plot.title = element_text(size = axtitle, hjust = 0.5),
          plot.background = element_rect(fill = NA, colour = NA)) +
    ggtitle(univtitles[p])
  
  plot.univ <- plot.univ +
    geom_text(data = stars.plot.univ, label = stars.plot.univ$label, 
              position = position_dodge(0.5), 
              colour = 'black', size = 5) 
  
  if (univ.diff.t$p.value < 0.05){
    
    plot.univ <- plot.univ +
      geom_signif(comparisons = list(c("Other", "Self")), map_signif_level = FALSE, colour = "black", 
                  tip_length = 0, test = NULL, annotations = star.diff)
  }
  
  # print(plot.univ)
  
  plot.name <- paste0("plot.",univ)
  
  assign(plot.name, plot.univ)
  
  # if (saveplots == 1) {dev.off()}
  
}

```

## Analyse QCAE

```{r, warning=FALSE, message=FALSE, echo=FALSE}

# correlation between QCAE AE and QCAE CE

o.ae.ce.corr <- cor.test(d.wide$QCAE_AE, d.wide$QCAE_CE)

# correlation between other_ACCg_eff_RSA and QCAE

o.accg.ae.corr <- cor.test(d.wide$other_ACCg_eff_RSA, d.wide$QCAE_AE)
o.accg.ce.corr <- cor.test(d.wide$other_ACCg_eff_RSA, d.wide$QCAE_CE)

# difference between correlations

o.accg.corr.diff <- paired.r(o.accg.ae.corr[["estimate"]][["cor"]], o.accg.ce.corr[["estimate"]][["cor"]], o.ae.ce.corr[["estimate"]][["cor"]], n = length(!is.na(d.wide$QCAE_AE)), twotailed = F)

# correlation between other_ACCg_force and QCAE

o.accg.ae.corr.f <- cor.test(d.wide$other_ACCg_force, d.wide$QCAE_AE)
o.accg.ce.corr.f <- cor.test(d.wide$other_ACCg_force, d.wide$QCAE_CE)

# correlations with average number of times work for other

d.choice <- read.csv('data/K_values_choices_PM_fmri_two_k_one_beta.csv') %>% 
  rename("scanningID" = ID)

d.choice$other_choice_minus_self_choice <- d.choice$other_choice - d.choice$self_choice

mean.work.other <- round(mean(d.choice$other_choice),2)
mean.work.self <- round(mean(d.choice$self_choice),2)

rand.force <- ranef(m.force.rs[["full_model"]][[3]])
rand.force <- rand.force[["ID"]]
rand.force$ID <- unique(m.force.rs[["data"]][["ID"]])

d.force <- d.tbt.f %>% 
  dplyr::group_by(ID, Recipient) %>%
  dplyr::summarise(av_force = mean(Force_norm, na.rm = T), .groups = "drop") %>%
  pivot_wider(id_cols = "ID", names_from = "Recipient", values_from = "av_force", names_prefix = "av_force_")

d.force <- left_join(d.force, rand.force, by = "ID")

d.wide <- left_join(d.wide, d.choice %>% select("scanningID", contains("choice")), by = "scanningID")

d.wide$ID <- c(1:38)
d.wide$ID <- factor(d.wide$ID)

d.choice <- d.tbt %>%
  dplyr::group_by(ID, Recipient) %>%
  dplyr::summarise(av_choice = mean(chosen, na.rm = T), .groups = "drop") %>%
  pivot_wider(id_cols = "ID", names_from = "Recipient", values_from = "av_choice", names_prefix = "choice_")

d.force <- left_join(d.force, d.choice, by = "ID") 
d.wide <- left_join(d.wide, d.force, by = "ID")

d.k.id <- d.k %>% select(!"ID")
d.k.id <- left_join(d.k.id, d.wide %>% select("ID", "scanningID"), by = "scanningID")
d.tbt <- left_join(d.tbt, d.k.id %>% select("ID", "scanningID", "k", "Recipient"), by = c("ID", "Recipient"))
d.tbt$SV <- d.tbt$Reward.r - (d.tbt$k * ((d.tbt$Effort.r-1) ^ 2)) # add subjective value

# correlation between other_ACCg_eff_RSA and other force

o.accg.for.corr <- cor.test(d.wide$other_ACCg_eff_RSA, d.wide$av_force_Other)

# correlation between other_ACCg_eff_RSA and other choice

o.accg.choice.corr <- cor.test(d.wide$other_ACCg_eff_RSA, d.wide$choice_Other)

# correlation between QCAE and other choice

o.choice.ae.corr <- cor.test(d.wide$QCAE_AE, d.wide$other_choice)
os.choice.ae.corr <- cor.test(d.wide$QCAE_AE, d.wide$other_choice_minus_self_choice)

# correlation between QCAE and other force

o.force.ae.corr <- cor.test(d.wide$QCAE_AE, d.wide$av_force_Other)
o.force.ce.corr <- cor.test(d.wide$QCAE_CE, d.wide$av_force_Other)

# difference between correlations

o.force.corr.diff <- paired.r(o.force.ae.corr[["estimate"]][["cor"]], o.force.ce.corr[["estimate"]][["cor"]], o.ae.ce.corr[["estimate"]][["cor"]], n = length(!is.na(d.wide$QCAE_AE)), twotailed = F)


```

```{r, warning=FALSE, message=FALSE, echo=FALSE, fig.height=plotH, fig.width=plotW*1.5}

## QCAE scatterplot

# if (saveplots == 1) {tiff("plotpanels/other_ACCg_effort_QCAE_AE.tiff", units="in", width = plotW*1.5, height = plotH, res = resolution)}

plot.qcae.ae <- ggplot(d.wide, aes(x = other_ACCg_eff_RSA, y = QCAE_AE)) + 
  geom_point(alpha = 0.7, size = 5, show.legend = FALSE, colour = "#326199") + 
  geom_smooth(method = 'lm', alpha = 0.3, size = 2, colour = "#326199", fill = "#326199", show.legend = FALSE) + 
  geom_smooth(method = 'lm', alpha = 0, size = 2, colour = "#326199") +
  scale_x_continuous(n.breaks = 6, name = paste0(taulabel), limits = c(-0.05, 0.15)) +
  scale_y_continuous(name = "QCAE<br>
        <span style='font-size:12pt'>(Affective empathy subscale)</span>") + 
  ggtitle("ACCg other effort pattern and\naffective empathy") +
  theme_classic() + 
  theme(legend.position = 'none') +
  theme(axis.text = element_markdown(size = axtext),
        axis.title.x = element_markdown(size = axtitle),
        axis.title.y = element_markdown(size = axtitle),
        plot.title = element_text(size = axtitle, hjust = 0.5)) +
  guides(shape = guide_legend(override.aes = list(size = 2))) +
  annotate(geom='richtext', x = 0.08, y = 24.7, 
           label = paste0("_r_","<sub>(", (length(!is.na(d.wide$QCAE_AE))-2),")</sub>=", 
                          format(round(o.accg.ae.corr[["estimate"]][["cor"]],digits=2), nsmall=2),", _p_", 
                          pvalr(o.accg.ae.corr[["p.value"]])),
           fill = NA, label.color = NA, size = 6)

# plot.qcae.ae

# if (saveplots == 1) {dev.off()}

# if (saveplots == 1) {tiff("plotpanels/other_ACCg_effort_RSA_other_force.tiff", units="in", width = plotW*1.5, height = plotH, res = resolution)}

plot.accg.rsa.for <- ggplot(d.wide, aes(x = other_ACCg_eff_RSA, y = av_force_Other)) + 
  geom_point(alpha = 0.7, size = 5, show.legend = FALSE, colour = "#326199") + 
  geom_smooth(method = 'lm', alpha = 0.3, size = 2, colour = "#326199", fill = "#326199", show.legend = FALSE) + 
  geom_smooth(method = 'lm', alpha = 0, size = 2, colour = "#326199") +
  scale_x_continuous(n.breaks = 6, name = paste0(taulabel)) +
  scale_y_continuous(name = "Average force for other") + 
  ggtitle("ACCg other effort pattern during\nchoice and force exerted for other") +
  theme_classic() + 
  theme(legend.position = 'none') +
  theme(axis.text = element_markdown(size = axtext-4),
        axis.title.x = element_markdown(size = axtitle-4),
        axis.title.y = element_markdown(size = axtitle-4),
        plot.title = element_text(size = axtitle-4, hjust = 0.5)) +
  annotate(geom='richtext', x = 0.1, y = 0.42, 
           label = paste0("_r_","<sub>(", (length(!is.na(d.wide$av_force_Other))-2),")</sub>=", 
                          format(round(o.accg.for.corr[["estimate"]][["cor"]],digits=2), nsmall=2),", _p_", 
                          pvalr(o.accg.for.corr[["p.value"]])),
           fill = NA, label.color = NA, size = 4)

# plot.accg.rsa.for

# if (saveplots == 1) {dev.off()}

# if (saveplots == 1) {tiff("plotpanels/other_ACCg_effort_RSA_other_force.tiff", units="in", width = plotW*1.5, height = plotH, res = resolution)}

plot.accg.for.choice <- ggplot(d.wide, aes(x = other_ACCg_force, y = choice_Other)) + 
  geom_point(alpha = 0.7, size = 5, show.legend = FALSE, colour = "#326199") + 
  geom_smooth(method = 'lm', alpha = 0.3, size = 2, colour = "#326199", fill = "#326199", show.legend = FALSE) + 
  geom_smooth(method = 'lm', alpha = 0, size = 2, colour = "#326199") +
  scale_x_continuous(n.breaks = 6, name = paramestlab) +
  scale_y_continuous(name = "Proportion accepted for other") + 
  ggtitle("ACCg force for other (univariate)\nand choices to work for other") +
  theme_classic() + 
  theme(legend.position = 'none') +
  theme(axis.text = element_markdown(size = axtext-4),
        axis.title.x = element_markdown(size = axtitle-4),
        axis.title.y = element_markdown(size = axtitle-4),
        plot.title = element_text(size = axtitle-4, hjust = 0.5)) +
  guides(shape = guide_legend(override.aes = list(size = 2))) +
  annotate(geom='richtext', x = 1.2, y = 0.7, 
           label = paste0("_r_","<sub>(", (length(!is.na(d.wide$other_ACCg_force))-2),")</sub>=", 
                          format(round(o.accg.choice.corr[["estimate"]][["cor"]],digits=2), nsmall=2),", _p_", 
                          pvalr(o.accg.choice.corr[["p.value"]])),
           fill = NA, label.color = NA, size = 4)

# plot.accg.for.choice

# if (saveplots == 1) {dev.off()}

```

## Figure 4

```{r, warning=FALSE, message=FALSE, echo=FALSE, fig.height=plotH*1.3, fig.width=corrplotW*1.75}

# combine plots from above with images of brain regions and icons

ACCg.roi.brain <- "images/ACCg_roi_zoom.jpg"
ACCg.roi.brain <- ggdraw() + draw_image(ACCg.roi.brain)

effort.rdm <- "images/Effort_task_RDM.jpg"
effort.rdm <- ggdraw() + draw_image(effort.rdm)

ACCg.force.brain <- "images/ACCg_force_zoom.jpg"
ACCg.force.brain <- ggdraw() + draw_image(ACCg.force.brain)

force.task <- "images/Force_task.jpg"
force.task <- ggdraw() + draw_image(force.task)

ACCg.roi.effort.rdm <- plot_grid(ACCg.roi.brain, NULL, effort.rdm, nrow = 3, rel_heights = c(3,0.5,2.3))

other.self.effort <- plot_grid(plot.Effort.ACCg, plot.qcae.ae, ncol = 2, rel_widths = c(0.9,1.4), align = "h")

ACCg.force.task <- plot_grid(ACCg.force.brain, NULL, force.task, nrow = 3, rel_heights = c(3,0.5,2.3))

f4a.title <- ggdraw() + 
  draw_label(
    "Other effort pattern > Self effort pattern",
    x = 0.5, hjust = 0.5, size = 18) +
  theme(plot.background = element_rect(fill = NA, colour = NA))

f4b.title <- ggdraw() + 
  draw_label(
    "Other force > Self force",
    x = 0.5, hjust = 0.5, size = 18) +
  theme(plot.background = element_rect(fill = NA, colour = NA))

fig4 <- plot_grid(NULL, plot.Effort.ACCg, plot.qcae.ae, NULL, plot.ACCg_force, NULL, ncol = 6, rel_widths = c(2.1,1.8,3.2,2.2,1.8,0.1), axis = "tb", align = "h")

fig4 <- ggdraw() +
  draw_plot(fig4) +
  draw_plot(ACCg.roi.effort.rdm, x = 0.1, y = 0.5, width = 0.7, height = 0.5, hjust = 0.5, vjust = 0.5) +
  draw_plot(ACCg.force.task, x = 0.75, y = 0.5, width = 0.7, height = 0.5, hjust = 0.5, vjust = 0.5)

fig4titles <- plot_grid(f4a.title, f4b.title, ncol = 2, rel_widths = c(7.2, 3.8), labels = "AUTO", label_size = axtitle)

fig4 <- plot_grid(fig4titles, fig4, nrow = 2, rel_heights = c(0.1,1))

if (saveplots == 1) {tiff("figures/Figure4.tiff", units="in", width = corrplotW*1.75, height = plotH*1.3, res = resolution)}

fig4

if (saveplots == 1) {dev.off()}

```

**Figure 4. ACCg codes patterns of effort for others only, varies with level of affective empathy, and tracks effort required to benefit others only.**

```{r, warning=FALSE, message=FALSE, echo=FALSE, fig.height=plotH, fig.width=corrplotW}

# create panels combining graphs with images of brain regions

self.other.RSA.brain <- "images/midbrain_SV_RSA.jpg"
self.other.RSA.brain <- magick::image_transparent(
  magick::image_read(self.other.RSA.brain),
  color = "white"
)
self.other.RSA.brain <- ggdraw() + draw_image(self.other.RSA.brain)
self.other.RSA <- plot_grid(self.other.RSA.brain, plot.SV.midbrain, nrow = 1, labels = "AUTO")

# self.other.RSA

SV.rdm <- "images/SV_RDM.jpg"
SV.rdm <- ggdraw() + draw_image(SV.rdm)

dACC.AI.SV.univ.brain <- "images/dACC_AI_SV_conj.jpg"
dACC.AI.SV.univ.brain <- ggdraw() + draw_image(dACC.AI.SV.univ.brain)
dACC.AI.SV.univ <- plot_grid(dACC.AI.SV.univ.brain, plot.dacc_dmpfc_svc_conj, plot.AI_conj_SVC, nrow = 1, axis = "l", labels = "AUTO")

# dACC.AI.SV.univ

dACC.AI.SV.RSA.brain <- "images/dACC_AI_SV_RSA.jpg"
dACC.AI.SV.RSA.brain <- ggdraw() + draw_image(dACC.AI.SV.RSA.brain)
dACC.AI.SV.RSA <- plot_grid(dACC.AI.SV.RSA.brain, plot.SV.dACC, plot.SV.AI, nrow = 1, axis = "l", labels = "AUTO")

# dACC.AI.SV.RSA

self.other.univ.brain <- "images/AI_SV_svc.jpg"
self.other.univ.brain <- ggdraw() + draw_image(self.other.univ.brain)
self.other.univ <- plot_grid(self.other.univ.brain, plot.AI_SV_svc, nrow = 1, labels = "AUTO")

# self.other.univ

```

## Figure 5

```{r, warning=FALSE, message=FALSE, echo=FALSE, fig.height=plotH*1.4, fig.width=corrplotW*1.75}

# combine panels from above

# f5top.title <- ggdraw() + 
#   draw_label(
#     "Self > Other",
#     x = 0.5, hjust = 0.5, size = 18, angle = 90) +
#   theme(plot.background = element_rect(fill = NA, colour = NA))
# 
# f5bottom.title <- ggdraw() + 
#   draw_label(
#     "Other ^ Self",
#     x = 0.5, hjust = 0.5, size = 18, angle = 90) +
#   theme(plot.background = element_rect(fill = NA, colour = NA))

f5left.title <- ggdraw() + 
  draw_label(
    "Multivariate subjective value pattern for Self > Other",
    x = 0.5, hjust = 0.5, size = 18, fontface = "bold") +
  theme(plot.background = element_rect(fill = NA, colour = NA))

f5right.title <- ggdraw() + 
  draw_label(
    "Univariate subjective value tracking for Self > Other",
    x = 0.5, hjust = 0.5, size = 18, fontface = "bold") +
  theme(plot.background = element_rect(fill = NA, colour = NA))

# fig5labels <- plot_grid(f5top.title, f5bottom.title, nrow = 2)

fig5titles <- plot_grid(f5left.title, f5right.title, ncol = 2)

fig5 <- plot_grid(NULL, NULL, plot.SV.midbrain, NULL, NULL, plot.AI_SV_svc, NULL, 
                  ncol = 7, nrow = 1, axis = "tblr", align = "hv", rel_widths = c(1,1,1,0.25,1.5,1,0.5),
                  labels = c("A", "", "", "", "B", "", ""), label_size = axtitle)

fig5 <- ggdraw() +
  draw_plot(fig5) +
  draw_plot(SV.rdm, x = 0.06, y = 0.5, width = 0.20, height = 0.20, hjust = 0.5, vjust = 0.5) +
  draw_plot(self.other.RSA.brain, x = 0.24, y = 0.5, width = 0.5, height = 0.5, hjust = 0.58, vjust = 0.5) +
  draw_plot(self.other.univ.brain, x = 0.66, y = 0.5, width = 0.5, height = 0.55, hjust = 0.5, vjust = 0.5) +
  # draw_plot(dACC.AI.SV.RSA.brain, x = 0.08, y = 0.22, width = 0.25, height = 0.25, hjust = 0.5, vjust = 0.5) +
  # draw_plot(dACC.AI.SV.univ.brain, x = 0.60, y = 0.22, width = 0.25, height = 0.25, hjust = 0.5, vjust = 0.5) +
  draw_line(x = c(0.5, 0.5), y = c(0.05, 0.95), color = "black", size = 0.5)

# fig5 <- plot_grid(f5top.title, fig5, ncol = 2, rel_widths = c(0.06,1))

fig5 <- plot_grid(fig5titles, fig5, nrow=2, rel_heights = c(0.06,0.5))

if (saveplots == 1) {tiff("figures/Figure5.tiff", units="in", width = corrplotW*1.85, height = plotH*1.4, res = resolution)}

fig5

if (saveplots == 1) {dev.off()}

```
**Figure 5. Self-benefitting and domain general representations and tracking of subjective value.**

## Figure 6

```{r, warning=FALSE, message=FALSE, echo=FALSE, fig.height=plotH*1.4, fig.width=corrplotW*1.75}

f6left.title <- ggdraw() + 
  draw_label(
    "Multivariate subjective value pattern for Other ^ Self",
    x = 0.5, hjust = 0.5, size = 18, fontface = "bold") +
  theme(plot.background = element_rect(fill = NA, colour = NA))

f6right.title <- ggdraw() + 
  draw_label(
    "Univariate subjective value tracking for Other ^ Self",
    x = 0.5, hjust = 0.5, size = 18, fontface = "bold") +
  theme(plot.background = element_rect(fill = NA, colour = NA))

fig6titles <- plot_grid(f6left.title, f6right.title, ncol = 2)

fig6 <- plot_grid(NULL, plot.SV.dACC, plot.SV.AI, NULL, NULL, plot.dacc_dmpfc_svc_conj, plot.AI_conj_SVC, 
                  ncol = 7, nrow = 1, axis = "tblr", align = "hv", rel_widths = c(1,1,1,0.25,1,1,1),
                  labels = c("A", "", "", "", "B", "", ""), label_size = axtitle)

fig6 <- ggdraw() +
  draw_plot(fig6) +
  draw_plot(dACC.AI.SV.RSA.brain, x = 0.08, y = 0.5, width = 0.5, height = 0.5, hjust = 0.5, vjust = 0.5) +
  draw_plot(dACC.AI.SV.univ.brain, x = 0.60, y = 0.5, width = 0.5, height = 0.5, hjust = 0.5, vjust = 0.5) +
  draw_line(x = c(0.5, 0.5), y = c(0.05, 0.95), color = "black", size = 0.5)

# fig6 <- plot_grid(f6bottom.title, fig6, ncol = 2, rel_widths = c(0.06,1))

fig6 <- plot_grid(fig6titles, fig6, nrow=2, rel_heights = c(0.06,0.5))

if (saveplots == 1) {tiff("figures/Figure6.tiff", units="in", width = corrplotW*1.85, height = plotH*1.4, res = resolution)}

fig6

if (saveplots == 1) {dev.off()}
```

**Figure 6. Multivariate and univariate patterns and signals of subjective value overlap in dACC/dmPFC and AI.**

# Supplementary

```{r, warning=FALSE, message=FALSE, echo=FALSE, fig.height=plotH, fig.width=corrplotW}

## create effort RDM heatmaps

efflabs <- c("", "", "e2", "", "",
             "", "", "e3", "", "",
             "", "", "e4", "", "",
             "", "", "e5", "", "",
             "", "", "e6", "", "")

# if (saveplots == 1) {tiff("plotpanels/Effort_RDM.tiff", units="in", res = resolution, width = plotH, height = plotH)}

rdm.eff <- ggplot(data = d.rdm.eff, aes(x=xcondition, y=ycondition, fill=value)) + 
  geom_raster() +
  scale_fill_gradientn(colours = rdmcols,
                       space = "Lab",
                       name="← Dissimilarity") +
  guides(fill = guide_colorbar(title.position = 'right', title.hjust = 0.5, 
                               frame.colour = NULL, barheight = 16, 
                               ticks = FALSE, label = FALSE, 
                               draw.ulim = FALSE, draw.llim = FALSE)) +
  theme_classic() + 
  theme(axis.text.x = element_markdown(size = axtext-2, angle = 90, vjust = 0.7),
        axis.text.y = element_markdown(size = axtext-2), 
        axis.title = element_blank(),
        legend.title = element_text(size = axtitle, angle = 270), 
        legend.text = element_text(size = axtext),
        line = element_blank(),
        plot.title = element_text(size = axtitle, hjust = 0.5)) +
  scale_x_discrete(labels = efflabs) +
  scale_y_discrete(limits = rev(levels(d.rdm.eff$ycondition)),
                   labels = rev(efflabs))

# rdm.eff

# if (saveplots == 1) {dev.off()}

rdm.eff.s <- rdm.eff + 
  ggtitle("Self effort")

rdm.eff.o <- rdm.eff + 
  ggtitle("Other effort")

## create sV RDM heatmaps

# if (saveplots == 1) {tiff("plotpanels/sV_RDM_self.tiff", units="in", res = resolution, width = plotH, height = plotH)}

rdm.sV.s <- ggplot(data = d.rdm.sV.s, aes(x=xcondition, y=ycondition, fill=value)) + 
  geom_raster() +
  scale_fill_gradientn(colours = rdmcols,
                       space = "Lab",
                       name="← Dissimilarity") +
  guides(fill = guide_colorbar(title.position = 'right', title.hjust = 0.5, 
                               frame.colour = NULL, barheight = 16, 
                               ticks = FALSE, label = FALSE, 
                               draw.ulim = FALSE, draw.llim = FALSE)) +
  theme_classic() + 
  theme(axis.text.x = element_markdown(size = axtext-2, angle = 90, vjust = 0.7),
        axis.text.y = element_markdown(size = axtext-2), 
        axis.title = element_blank(),
        legend.title = element_text(size = axtitle, angle = 270), 
        legend.text = element_text(size = axtext),
        line = element_blank(),
        plot.title = element_text(size = axtitle, hjust = 0.5)) +
  
  scale_y_discrete(limits = rev(levels(d.rdm.sV.s$ycondition))) + 
  ggtitle("Self subjective value")

# rdm.sV.s

# if (saveplots == 1) {dev.off()}

# if (saveplots == 1) {tiff("plotpanels/sV_RDM_other.tiff", units="in", res = resolution, width = plotH, height = plotH)}

rdm.sV.o <- ggplot(data = d.rdm.sV.o, aes(x=xcondition, y=ycondition, fill=value)) + 
  geom_raster() +
  scale_fill_gradientn(colours = rdmcols,
                       space = "Lab",
                       name="← Dissimilarity") +
  guides(fill = guide_colorbar(title.position = 'right', title.hjust = 0.5, 
                               frame.colour = NULL, barheight = 16, 
                               ticks = FALSE, label = FALSE, 
                               draw.ulim = FALSE, draw.llim = FALSE)) +
  theme_classic() + 
  theme(axis.text.x = element_markdown(size = axtext-2, angle = 90, vjust = 0.7),
        axis.text.y = element_markdown(size = axtext-2), 
        axis.title = element_blank(),
        legend.title = element_text(size = axtitle, angle = 270), 
        legend.text = element_text(size = axtext),
        line = element_blank(),
        plot.title = element_text(size = axtitle, hjust = 0.5)) +
  scale_y_discrete(limits = rev(levels(d.rdm.sV.o$ycondition))) + 
  ggtitle("Other subjective value")

# rdm.sV.o

# if (saveplots == 1) {dev.off()}

## create reward RDM heatmaps

# if (saveplots == 1) {tiff("plotpanels/Reward_RDM.tiff", units="in", res = resolution, width = plotH, height = plotH)}

rewlabs <- str_replace(rdmnames, "e[:digit:]", "")

rdm.rew <- ggplot(data = d.rdm.rew, aes(x=xcondition, y=ycondition, fill=value)) + 
  geom_raster() +
  scale_fill_gradientn(colours = rdmcols,
                       space = "Lab",
                       name="← Dissimilarity") +
  guides(fill = guide_colorbar(title.position = 'right', title.hjust = 0.5, 
                               frame.colour = NULL, barheight = 16, 
                               ticks = FALSE, label = FALSE, 
                               draw.ulim = FALSE, draw.llim = FALSE)) +
  theme_classic() + 
  theme(axis.text.x = element_markdown(size = axtext-2, angle = 90, vjust = 0.7),
        axis.text.y = element_markdown(size = axtext-2), 
        axis.title = element_blank(), 
        legend.title = element_text(size = axtitle, angle = 270), 
        legend.text = element_text(size = axtext),
        line = element_blank(),
        plot.title = element_text(size = axtitle, hjust = 0.5)) +
  scale_x_discrete(labels = rewlabs) +
  scale_y_discrete(limits = rev(levels(d.rdm.rew$ycondition)),
                   labels = rev(rewlabs))

# rdm.rew

# if (saveplots == 1) {dev.off()}

rdm.rew.s <- rdm.rew + 
  ggtitle("Self reward")

rdm.rew.o <- rdm.rew + 
  ggtitle("Other reward")

```

## Figure S1

```{r, warning=FALSE, message=FALSE, echo=FALSE, fig.height=corrplotW*2, fig.width=corrplotW*1.5}

# combine heatmaps from above 

# extract the legend from one of the plots
legend <- get_legend(
  # create some space to the left of the legend
  rdm.eff.o + theme(legend.box.margin = margin(0, 0, 0, 12))
)

rdm.fig <- plot_grid(rdm.eff.o + theme(legend.position = "none"), 
                     rdm.eff.s + theme(legend.position = "none"), 
                     NA, 
                     rdm.sV.o + theme(legend.position = "none"), 
                     rdm.sV.s + theme(legend.position = "none"), 
                     legend, 
                     rdm.rew.o + theme(legend.position = "none"), 
                     rdm.rew.s + theme(legend.position = "none"), 
                     NA, 
                     nrow = 3, ncol = 3, rel_widths = c(1,1,0.3), 
                     label_size = axtitle, labels = c("A", "", "", "B", "", "", "C", "", ""), axis = "l", align = "hv")

if (saveplots == 1) {tiff("figures/FigureS1.tiff", units="in", width = corrplotW*1.5, height = corrplotW*2, res = resolution)}

rdm.fig

if (saveplots == 1) {dev.off()}


```

**Figure S1. Model RDMs for effort, subjective value and reward. Related to Figure 1.**

### Figure S2

```{r, warning=FALSE, message=FALSE, echo=FALSE, fig.width=corrplotW*1, fig.height=plotH}

if (saveplots == 1) {tiff("figures/FigureS2.tiff", units="in", res = resolution, width = corrplotW, height = plotH)}

plot.force.corrs <- plot_grid(plot.accg.rsa.for, plot.accg.for.choice, nrow = 1, label_size = axtitle, labels = c("D", "E"), axis = "l", align = "hv")

plot.force.corrs

if (saveplots == 1) {dev.off()}

```

### Figure S3

```{r, warning=FALSE, message=FALSE, echo=FALSE, fig.height=plotH*1.5, fig.width=corrplotW*2}

plot.rel.bic.rs <- ggdraw(plot.rel.bic.rs) +
  draw_plot(plot.prop.bic10, x = 0.44, y=0.8, hjust = 0.5, vjust = 0.5, width = 0.5, height = 0.5) +
  draw_line(x = c(0.44, 0.44), y = c(0.45, 0.57), color = "#7031A0", size = 2, alpha = 0.8) +
  draw_plot(plot.prop.bic19, x = 0.78, y=0.8, hjust = 0.5, vjust = 0.5, width = 0.5, height = 0.5) +
  draw_line(x = c(0.78, 0.78), y = c(0.45, 0.57), color = "#a0319a", size = 2, alpha = 0.8) +
  draw_plot(plot.prop.bic22, x = 0.895, y=0.8, hjust = 0.5, vjust = 0.5, width = 0.5, height = 0.5) +
  draw_line(x = c(0.895, 0.895), y = c(0.45, 0.57), color = "#a03161", size = 2, alpha = 0.8) 

```

```{r, warning=FALSE, message=FALSE, echo=FALSE, fig.width=corrplotW*2, fig.height=plotH*5}

mi.rs.plot <- plot_grid(bm.rs.plot, 
                        bicp.rs.plot, 
                        ncol = 2, align = "tb", axis = "lrtb", labels = "AUTO")

plot.rel.bic.rs <- plot_grid(plot.rel.bic.rs, NA, ncol = 2, rel_widths = c(1,0.1))

plot.rel.bic.rs2 <- plot_grid(plot.rel.bic.rs2, NA, ncol = 2, rel_widths = c(1,0.1))

plot.rel.bic.rs2.leg <- ggdraw(plot.rel.bic.rs2) +
  draw_plot(leg.rel.bic.rs, x = 0.3, y = 0.05)

bic.rs.mi.plot <- plot_grid(mi.rs.plot, plot.rel.bic.rs, plot.rel.bic.rs2.leg, plot.rel.bic.3, plot.rel.bic.10, nrow = 5, labels = c("", "C", "", "D", "E"))

if (saveplots == 1) {tiff("figures/FigureS3.tiff", units="in", width = corrplotW*2, height = plotH*5, res = resolution)}

bic.rs.mi.plot

if (saveplots == 1) {dev.off()}

```
**Figure S3. Model identifiability and model comparison with all models and different Κ bounds. Related to Figure 2. ** 

### Figure S5

```{r, warning=FALSE, message=FALSE, echo=FALSE, fig.width=corrplotW*2, fig.height=plotH*1.25}

d.rsa <- d %>% pivot_longer(cols = ends_with(c('eff_RSA','rew_RSA', 'sV_RSA')), 
                            names_to = c('Area', 'Measure'),
                            names_sep = '_') %>% 
  mutate(Measure = factor(Measure, levels = c('eff', 'rew', 'sV'), 
                          labels = c('Effort', 'Reward', 'SV')))

stars <- p.kend %>% 
  mutate(Measure = factor(Measure, levels = c('eff', 'rew', 'sV'), labels = c('Effort', 'Reward', 'SV'))) %>% 
  mutate(Recipient = factor(Recipient)) %>% 
  mutate(label = "") %>% 
  mutate(value = 0.15)

stars$label[stars$pvalFDR < 0.05] <- "*"
stars$label[stars$pvalFDR < 0.01] <- "**"
stars$label[stars$pvalFDR < 0.001] <- "***"

toplot <- c("vmPFC", "VS")
toplottitles <- c("vmPFC", "Ventral striatum")

for (p in 1:length(toplot)){
  
  area <- toplot[p]
  
  d.rsa.plot <- d.rsa %>% filter(Area == area) %>% droplevels()
  
  if (saveplots == 1) {tiff(paste0('plotpanels/RSA_',area,'.tiff'), units="in", width = plotW, height = plotH, res = resolution)}
  
  plot.rsa <- ggplot(d.rsa.plot, aes(x = Measure, y = value, fill = Recipient, color = Recipient)) + 
    stat_summary(fun = mean, size = 0.5, geom = 'bar', alpha = 0.8, colour = 'black',
                 position=position_dodge(0.5), width = 0.5) +
    geom_point(position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.5),
               size = 2, alpha = 0.8, show.legend = FALSE) +
    stat_summary(fun = mean, size = 0.5, geom = 'bar', alpha = 0, colour = 'black',
                 position=position_dodge(0.5), width = 0.5) +
    stat_summary(fun.data = mean_se, geom = 'errorbar', colour = 'black', width = 0, position=position_dodge(0.5)) + 
    scale_y_continuous(name = taulabel, limits = c(-0.14,0.22)) +
    scale_x_discrete(name = '') +
    scale_fill_manual(values = otherselfcols) +
    scale_color_manual(values = otherselfdots) +
    ggtitle(toplottitles[p]) +
    facet_wrap(facets = vars(fct_rev(Recipient))) +
    theme_classic() + 
    theme(legend.position = 'none',
          axis.text.y=element_text(size = axtext),
          axis.text.x=element_text(size = axtext),
          axis.title.y=element_markdown(size = axtitle),
          strip.text = element_text(size = axtext),
          plot.title = element_text(size = axtitle, hjust = 0.5), 
          plot.background = element_rect(fill = NA, colour = NA)) 
  
  stars.plot <- stars %>% filter(Area == area) %>% droplevels()
  
  plot.rsa <- plot.rsa +
    geom_text(data = stars.plot, label = stars.plot$label, 
              position = position_dodge(0.5), 
              colour = 'black', size = 5) 
  
  # print(plot.rsa)
  
  plot.name <- paste0("plot.", area)
  
  assign(plot.name, plot.rsa)
  
}

figSX <- plot_grid(plot.vmPFC, plot.VS, ncol = 2, labels = "AUTO", label_size = axtitle)

if (saveplots == 1) {tiff("figures/FigureSX.tiff", units="in", width = corrplotW*1.5, height = corrplotW*0.5, res = resolution)}

figSX

if (saveplots == 1) {dev.off()}

```

**Figure S5. vmPFC and VS multivariate patterns of effort, reward and subjective value. Related to Table S6.**

### Table 1

```{r, warning=FALSE, message=FALSE, echo=FALSE}

self.other.mean.se.diff.f <- self.other.mean.se.diff %>% 
  mutate(p = pvalr(p)) %>% 
  mutate(p = str_replace(p, pattern = "=", replacement = ""))

kable(self.other.mean.se.diff.f,
      align = c(rep('l',1),rep('c',ncol(self.other.mean.se.diff.f)-1)),
      caption = paste0("Summary statistics and Wilcoxon comparisons between self and other for behavioural variables")) %>% kable_styling()

if (savecsvs == 1) {write.table(self.other.mean.se.diff.f, file = "output/Table_1.csv", sep = ",", row.names = F)}

```

### Table S1

```{r, warning=FALSE, message=FALSE, echo=FALSE}

r.choice.rs$p[!is.na(r.choice.rs$p)] <- pvalr(r.choice.rs$p[!is.na(r.choice.rs$p)])
r.choice.rs <- r.choice.rs %>% 
  mutate(p = str_replace(p, pattern = "=", replacement = ""))

kable(r.choice.rs,
      align = c('l',rep('c',(ncol(r.choice.rs)-1))),
      caption = "Generalised linear mixed-effects model predicting choices") %>% kable_styling()

if (savecsvs == 1) {write.table(r.choice.rs, file = "output/Table_S1.csv", sep = ",", row.names = F)}

```

### Table S2

```{r, warning=FALSE, message=FALSE, echo=FALSE}

r.force.rs$p[!is.na(r.force.rs$p)] <- pvalr(r.force.rs$p[!is.na(r.force.rs$p)])
r.force.rs <- r.force.rs %>% 
  mutate(p = str_replace(p, pattern = "=", replacement = ""))

kable(r.force.rs,
      align = c('l',rep('c',(ncol(r.force.rs)-1))),
      caption = "Linear mixed-effects model predicting normalised force") %>% kable_styling()

if (savecsvs == 1) {write.table(r.force.rs, file = "output/Table_S2.csv", sep = ",", row.names = F)}

```
### Table S3

```{r, warning=FALSE, message=FALSE, echo=FALSE}

p.kend.f <- p.kend %>% 
  subset(Area == c("vmPFC", "VS")) %>% 
  mutate(Measure = factor(Measure, levels = c('eff', 'rew', 'sV'), 
                          labels = c('effort RDM', 'reward RDM', 'subjective value RDM'))) %>% 
  arrange(Measure, Recipient, Area) %>% 
  mutate(pval = pvalr(pval)) %>% 
  mutate(pval = str_replace(pval, pattern = "=", replacement = "")) %>% 
  mutate(pvalFDR = pvalr(pvalFDR)) %>% 
  mutate(pvalFDR = str_replace(pvalFDR, pattern = "=", replacement = ""))

kable(p.kend.f,
      align = c(rep('l',3),rep('c',4)),
      caption = paste0(taulabel, " correlations between brain RDMs and model RDMs")) %>% kable_styling()

if (savecsvs == 1) {write.table(p.kend.f, file = "output/Table_S3.csv", sep = ",", row.names = F)}

```

### Table S4

```{r, warning=FALSE, message=FALSE, echo=FALSE}

p.reweff.diff.f <- p.reweff.diff %>% 
  mutate(Measure = factor(Measure, levels = c('self', 'other'), 
                          labels = c('self RDM', 'other RDM'))) %>% 
  arrange(Contrast, Measure, Area) %>% 
  mutate(pval = pvalr(pval)) %>% 
  mutate(pval = str_replace(pval, pattern = "=", replacement = "")) 

kable(p.reweff.diff.f,
      align = c(rep('l',3),rep('c',5)),
      caption = paste0("Contrasts between RDMs")) %>% kable_styling()

if (savecsvs == 1) {write.table(p.reweff.diff.f, file = "output/Table_S4.csv", sep = ",", row.names = F)}

```

### Table S5

```{r, warning=FALSE, message=FALSE, echo=FALSE}

p.kend.f <- p.kend %>% 
  subset(Area != c("vmPFC", "VS")) %>% 
  mutate(Measure = factor(Measure, levels = c('eff', 'rew', 'sV'), 
                          labels = c('effort RDM', 'reward RDM', 'subjective value RDM'))) %>% 
  arrange(Measure, Recipient, Area) %>% 
  mutate(pval = pvalr(pval)) %>% 
  mutate(pval = str_replace(pval, pattern = "=", replacement = "")) %>% 
  mutate(pvalFDR = pvalr(pvalFDR)) %>% 
  mutate(pvalFDR = str_replace(pvalFDR, pattern = "=", replacement = ""))

kable(p.kend.f,
      align = c(rep('l',3),rep('c',4)),
      caption = paste0(taulabel, " correlations between brain RDMs and model RDMs")) %>% kable_styling()

if (savecsvs == 1) {write.table(p.kend.f, file = "output/Table_S5.csv", sep = ",", row.names = F)}

```